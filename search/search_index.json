{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Vatpy","text":"<p>Vatpy (Visualisation of Arepo in the Terminal using PYthon) is a light-weight, highly customisable, visualisation tool-kit for astrophysical simulations performed using the Arepo code (Springel 2010). </p> <p>Many of its functionalities can be generally applied to simulations made by Arepo (as long as the output is in HDF5-format), however, more specific capabilities,  such as creating visual maps of the gas chemistry, is at the moment only adapted to simulations run using the ArepoNoctua numerical framework (Petersson et al. 2025).</p>"},{"location":"#example-gallery","title":"Example Gallery","text":"<p>Below you can see a set of visual maps from the Noctua suite of simulations (Petersson et al. 2025), highlighting some key quantities, such as the total column density of gas (top left), the average gas temperature (top right), the star formation rate surface density (bottom left), and the stellar age of newly formed star particles (bottom right), in a simulated low-mass dwarf galaxy at approximately 400 Myr in its evolution.</p> <p> Visual maps of a simulated low-mass dwarf galaxy from the Noctua suite of simulations (Petersson et al. 2025), made using Vatpy </p> <p></p> <p>Used by researchers at </p> <p> Last updated: 2025-09-04</p>"},{"location":"changelog/","title":"Changelog","text":"<p>TODO</p>"},{"location":"config/","title":"Config.sh options","text":"<p>TODO</p> <p> Last updated: 2025-09-05</p>"},{"location":"contact/","title":"Contact","text":""},{"location":"contact/#main-contributors","title":"Main contributors","text":"<p>Jonathan Petersson - PhD Student @ EPFL - jonathan.petersson@epfl.ch</p> <p> Last updated: 2025-09-04</p>"},{"location":"install/","title":"Installation","text":"<p>Here, we provide some general guidelines on how to install and set up Vatpy on your personal machine.</p>"},{"location":"install/#requirements","title":"Requirements","text":"<p>Version requirements are not neccessarily strict. The provided versions are the ones at which Vatpy have been tested at, and does not mean that Vatpy might run on older python/package versions.</p> <pre><code>python&gt;=3.12.7\nnumpy&gt;=1.26.4\nmatplotlib&gt;=3.9.2\nscipy&gt;=1.13.1\nh5py&gt;=3.11.0\nmatplotlib-label-lines&gt;=0.8.1\npycstruct&gt;=0.12.2\ncmasher\n</code></pre> <p>Only needed to deploy documentation.</p> <pre><code>mkdocs&gt;=1.6.1\nmkdocs-material&gt;=9.6.18\n</code></pre>"},{"location":"install/#recommended-set-up","title":"Recommended set-up","text":"<p>The recommended set-up of Vatpy is still in an early development stage. In the future, we hope to provide a complete package that can be easily installed via pip. But for now, we recommended the following set-up on your selected machine:</p> <ul> <li>Download the repository to your home directory, e.g. via HTTPS</li> </ul> <pre><code>cd ~\ngit clone https://github.com/AstroJPetersson/vatpy.git\n</code></pre> <p>This will create a directory called vatpy in your home directory.</p> <ul> <li>Now, enter the vatpy directory and copy <code>template-configv.py</code> to <code>configv.py</code>, i.e.</li> </ul> <pre><code>cd vatpy\ncp template-configv.py configv.py\n</code></pre> <p>The file <code>configv.py</code> contains your personal Vatpy configuration. Within this file, please make sure to change the <code>homedir</code> variable to the actual home directory on your personal machine.</p> <ul> <li>As a final step to make Vatpy work on your personal machine, you will have to export the path to your recently downloaded vatpy directory to your PYTHONPATH variable. For example, to ensure that this is always done when starting up a new session, you can e.g. add the following line to your <code>~/.bash_rc</code> or <code>~/.bash_profile</code> file</li> </ul> <pre><code>export PYTHONPATH=$PYTHONPATH:$HOME/vatpy\n</code></pre> <ul> <li>Voil\u00e0, that's it, you should now be ready to use Vatpy via Python scripts directly in the terminal, or inside Jupyter Notebooks. To make sure that Vatpy is installed correctly, simply try:</li> </ul> <pre><code>import vatpy as vp\n</code></pre> <ul> <li>If you encounter any issues when installing Vatpy, please do not hesitate to contact any of the main contributors to the code, or open up an issue on the GitHub repository (https://github.com/AstroJPetersson/vatpy).</li> </ul> <p> Last updated: 2025-09-04</p>"},{"location":"noctua/","title":"ArepoNoctua","text":"<p>TODO</p> <p> Last updated: 2025-09-05</p>"},{"location":"param/","title":"Parameter file options","text":"<p>TODO</p> <p> Last updated: 2025-09-05</p>"},{"location":"plot/","title":"How to make plots","text":""},{"location":"plot/#using-the-terminalplot-class","title":"Using the TerminalPlot class","text":"<p>TODO</p>"},{"location":"plot/#on-the-command-line","title":"On the command line","text":"<p>TODO</p>"},{"location":"plot/#inside-a-jupyter-notebook","title":"Inside a Jupyter Notebook","text":"<p>TODO</p> <p> Last updated: 2025-09-05</p>"},{"location":"terminal_plot/","title":"terminal_plot.py","text":""},{"location":"terminal_plot/#vatpy.terminal_plot.TerminalPlot","title":"<code>vatpy.terminal_plot.TerminalPlot</code>","text":"<p>Class to make simple, but informative, visual plots of Arepo snapshots, directly in the terminal (or notebook). Most importantly, it contains funtions to generate column density maps of the gas surface density, as well column density maps of various chemical species, such as HI, HII, and H2. The class also contains functions to inspect the surface density of dark matter and stellar components. For more details, see each function's individual description.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>str</code> <p>File to analyse</p> required <code>style</code> <code>str</code> <p>Matplotlib style option</p> <code>mplstyle</code> <code>path</code> <code>str</code> <p>Path to save file(s) at</p> <code>'./vplots'</code> <code>name</code> <code>str</code> <p>Name to save file(s) as</p> <code>None</code> <code>format</code> <code>str</code> <p>Format to save file(s) as (e.g. png/jpg/pdf/tiff)</p> <code>'png'</code> <code>vmin</code> <code>float</code> <p>Global vmin value</p> <code>None</code> <code>vmax</code> <code>float</code> <p>Global vmax value</p> <code>None</code> <code>xlim</code> <code>tuple</code> <p>Global x-axis min and max values</p> <code>None</code> <code>ylim</code> <code>tuple</code> <p>Global y-axis min and max values</p> <code>None</code> <code>ulengthselect</code> <code>str</code> <p>Unit length (see configv.py for more details)</p> <code>unit_for_length</code> <code>show</code> <code>bool</code> <p>If True, try to display the generated figure(s)</p> <code>True</code> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>class TerminalPlot:\n    '''Class to make simple, but informative, visual plots of Arepo snapshots,\n    directly in the terminal (or notebook). Most importantly, it contains\n    funtions to generate column density maps of the gas surface density, as\n    well column density maps of various chemical species, such as HI, HII, and\n    H2. The class also contains functions to inspect the surface density of\n    dark matter and stellar components. For more details, see each function's\n    individual description.\n\n    Args:\n        file (str): File to analyse\n        style (str): Matplotlib style option\n        path (str): Path to save file(s) at\n        name (str): Name to save file(s) as\n        format (str): Format to save file(s) as (e.g. png/jpg/pdf/tiff)\n        vmin (float): Global vmin value\n        vmax (float): Global vmax value\n        xlim (tuple): Global x-axis min and max values\n        ylim (tuple): Global y-axis min and max values\n        ulengthselect (str): Unit length (see configv.py for more details)\n        show (bool): If True, try to display the generated figure(s)\n    '''\n    def __init__(self, file, style=configv.mplstyle, path='./vplots',\n                 name=None, format='png', vmin=None, vmax=None, xlim=None,\n                 ylim=None, ulengthselect=configv.unit_for_length, show=True):\n\n        print(f'  * Setting up an environment to analyse {file}')\n\n        # Variables:\n        self.file = file\n        self.path = path\n        self.name = name\n        self.format = format\n        self.vmin, self.vmax = vmin, vmax\n        self.xlim, self.ylim = xlim, ylim\n        self.show = show\n\n        # Mpl style:\n        self.style = style\n        plt.style.use(f'{configv.homedir}/vatpy/mpl/{self.style}.mplstyle')\n\n        # Unit selection:\n        self.ulengthselect = ulengthselect\n        if self.ulengthselect == 'kpc':\n            self.ulength = const['kpc']\n        elif self.ulengthselect == 'pc':\n            self.ulength = const['pc']\n        else:\n            self.ulength = 1\n\n    ##########################################################################\n    ##########################################################################\n    def get_ranges(self, boxsize, box, xrange, yrange, zrange, bhfocus):\n        '''\n        Description: Function to get x, y, and z ranges.\n        '''\n        # Determine the coordinate ranges:\n        if not box:\n            if not xrange:\n                if bhfocus:\n                    xrange = (-boxsize/2, boxsize/2)\n                else:\n                    xrange = (0, boxsize)\n            if not yrange:\n                if bhfocus:\n                    yrange = (-boxsize/2, boxsize/2)\n                else:\n                    yrange = (0, boxsize)\n            if not zrange:\n                if bhfocus:\n                    zrange = (-boxsize/2, boxsize/2)\n                else:\n                    zrange = (0, boxsize)\n        else:\n            xrange = (box[0], box[1])\n            yrange = (box[0], box[1])\n            zrange = (box[0], box[1])\n\n        return xrange, yrange, zrange\n\n    def do_rotation(self, boxsize, axis, rotate, pos, bhfocus):\n        '''\n        Description: Function to rotate the position of particles.\n        '''\n        # If applicable, rotate the position of particles:\n        if rotate != 0:\n            rotation = Rotation.from_euler(axis, rotate, degrees=True)\n            if bhfocus:\n                pos = rotation.apply(pos)\n            else:\n                pos = rotation.apply(pos - boxsize/2)\n                pos += boxsize/2\n\n        return pos\n\n    def save(self, fig, funcname):\n        '''\n        Description: Function to save figures.\n        '''\n        # Name selection:\n        if self.name:\n            savename = self.name\n        else:\n            savename = funcname\n\n        # Figure name:\n        filestr = self.file.split('.')\n        figname = f'{savename}_{filestr[0]}'\n        if self.name:\n            figname = self.name + '_' + filestr[0][-3:]\n        figname += f'.{self.format}'\n\n        # Check if Vatpy plot directory already exists:\n        if os.path.isdir(self.path):\n            print('  * Path to save figure at detected')\n        else:\n            print('  * Path to save figure at NOT detected')\n            print('  * Creating a \\'vplots\\' directory')\n            os.mkdir(f'{os.getcwd()}/vplots/')\n\n        # Save figure:\n        fig.savefig(f'{self.path}/{figname}')\n        print('  * Figure saved as')\n        print(f'    - name: {figname}')\n        print(f'    - at: {self.path}')\n\n        return None\n\n    def display(self):\n        '''\n        Description: TODO\n        '''\n\n        if self.show is not True:\n            print('  * Display of figure is turned OFF')\n            plt.close()\n        else:\n            print('  * Display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def info(self):\n        '''Function to provide some general information about the given\n        snapshot, such as the physical time, size of the simulation domain,\n        number of particles, etc.\n        '''\n        # Read the data:\n        h, iu = read_hdf5(file=self.file)\n\n        time_int = h['Header'].attrs['Time']\n        time_phys = time_int * iu['utime'] / const['Myr']\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n        numpart = h['Header'].attrs['NumPart_ThisFile']\n\n        print('  * Snapshot information')\n        print(f'  | Time (internal) : {round(time_int, 2)}')\n        print(f'  | Time (physical) : {round(time_phys, 2)} Myr')\n        print(f'  | BoxSize       : {round(boxsize, 2)} kpc')\n        print('  |')\n        print('  | Number of particles')\n        print(f'  | PartType0 (gas)      : {numpart[0]}')\n        print(f'  | PartType1 (halo)     : {numpart[1]}')\n        print(f'  | PartType2 (disk)     : {numpart[2]}')\n        print(f'  | PartType3 (bulge)    : {numpart[3]}')\n        print(f'  | PartType4 (stars)    : {numpart[4]}')\n        print(f'  | PartType5 (bndry)    : {numpart[5]}')\n        print(f'  | Total Particle Count : {np.sum(numpart)}')\n        print('  | ')\n\n        mt = h['Header'].attrs['MassTable']\n        print('  | Table of Particle Masses [i.u.]')\n        print(f'  | {mt[0]}, {mt[1]}, {mt[2]}, {mt[3]}, {mt[4]}, {mt[5]}')\n\n        if numpart[4] &gt; 0:\n            print('  |')\n            print('  * Star particles detected')\n            print(f'  | Total number of stars: {numpart[4]}')\n            sne = h['PartType4']['NumberOfSupernovae'][:]\n            stars = h['PartType4']['StellarMasses'][:]\n            print(f'  | Total number of OB stars: {np.sum(sne)}')\n            print(f'  | Max mass of star particles: {np.max(stars)}')\n\n        if numpart[5] == 1:\n            print('  |')\n            print('  * A central BH detected')\n            Pbh = h['PartType5']['Coordinates'][0]\n            print(f'  | Coordinates [i.u.] : ({Pbh[0]}, {Pbh[1]}, {Pbh[2]})')\n            Vbh = h['PartType5']['Velocities'][0]\n            print(f'  | Velocities [i.u.]  : ({Vbh[0]}, {Vbh[1]}, {Vbh[2]})')\n            Mbh = h['PartType5']['Masses'][0] * iu['umass'] / const['Msol']\n            print(f'  | Mass [i.u.]        : {Mbh}')\n            IDbh = h['PartType5']['ParticleIDs'][0]\n            print(f'  | Particle ID        : {IDbh}')\n        elif numpart[5] &gt; 1:\n            print('  |')\n            print('  * Multiple BHs detected!')\n\n        print('  |')\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def density(self, axis='z', rotate=0, quantity='mass', bins=100,\n                interpolation='kdtree', bhfocus=False, funcname='dens',\n                xrange=None, yrange=None, zrange=None, box=None, cut=None):\n        '''Function to generate a column density map of the gas surface\n        density, with the possibility to also show the column density of\n        various chemical species, such as HI, HII, and H2. This is achieved by\n        first interpolating the selected gas quantity onto a grid, and later\n        doing a sum along the line-of-sight.\n\n        Args:\n            axis (str): Rotation axis\n            rotate (float): Amount of rotation\n            quantity (str): Gas quantity to visualise\n                            (options: mass/n/HI/HII/H2/CO/He/e)\n        '''\n        # Read the data:\n        print(f'  * Reading data of {self.file}')\n        h, iu = read_hdf5(file=self.file)\n        pos = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n        dens = h['PartType0']['Density'] * iu['udens']\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n\n        print('  * Generating a gas surface density map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Selection of gas quantity:\n        if (quantity != 'mass'):\n            num = number_density(h, iu)\n            dens = num[quantity]\n\n        # Rotation of particle positions:\n        pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos, bhfocus=bhfocus)\n\n        # Interpolation:\n        if interpolation == 'kdtree':\n            interpDens = interpolate_to_2d_kdtree(pos=pos, unit=self.ulength,\n                                                  values=dens, bins=bins,\n                                                  xrange=xrange, yrange=yrange,\n                                                  zrange=zrange, cut=cut)\n        else:\n            interpDens = interpolate_to_2d(pos=pos, unit=self.ulength,\n                                           values=dens, bins=bins,\n                                           xrange=xrange, yrange=yrange,\n                                           zrange=zrange, cut=cut)\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im = ax.imshow(np.log10(interpDens), vmin=self.vmin, vmax=self.vmax,\n                       extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                       origin='lower', cmap=configv.cmap['gas'])\n        if bhfocus:\n            ax.scatter(0, 0, s=40, c='k')\n        ax.text(0.95, 0.05, f'{time:.2f} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none',\n                      'boxstyle': 'round', 'alpha': 0.5})\n        ax.set_aspect('equal')\n        ax.set_xlabel(f'$x$ [{self.ulengthselect}]')\n        ax.set_ylabel(f'$y$ [{self.ulengthselect}]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n\n        # Colorbar:\n        if not cut:\n            dim = 2\n        else:\n            dim = 3\n        cbar_label = {\n            'HII': (r'$\\log_{10}(\\Sigma_{\\mathrm{HII}}$'\n                    r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'H2': (r'$\\log_{10}(\\Sigma_{\\mathrm{H}_2}$'\n                   r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'HI': (r'$\\log_{10}(\\Sigma_{\\mathrm{HI}}$'\n                   r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'CO': (r'$\\log_{10}(\\Sigma_{\\mathrm{CO}}$'\n                   r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'He': (r'$\\log_{10}(\\Sigma_{\\mathrm{He}}$'\n                   r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'e': (r'$\\log_{10}(\\Sigma_{e^{-}}$'\n                  r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'n': (r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                  r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'mass': (r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                     r' $[\\mathrm{g} \\ \\mathrm{cm}^{-%d}])$' % dim)\n        }\n\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im, cax=cax, label=cbar_label[quantity])\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        self.display()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def temperature(self, axis='z', rotate=0, bins=100, interpolation='kdtree',\n                    bhfocus=False, funcname='temp', xrange=None, yrange=None,\n                    zrange=None, box=None, cut=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print(f'  * Reading data of {self.file}')\n        h, iu = read_hdf5(file=self.file)\n        pos = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n        dens = h['PartType0']['Density'] * iu['udens']\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n        temp = temperature(h, iu)\n\n        print('  * Generating a gas temperature (density-weighted) map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Rotation of particle positions:\n        pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos, bhfocus=bhfocus)\n\n        # Interpolation:\n        if interpolation == 'kdtree':\n            interpTemp = interpolate_to_2d_kdtree(pos=pos, unit=self.ulength,\n                                                  values=temp, bins=bins,\n                                                  xrange=xrange, yrange=yrange,\n                                                  zrange=zrange, cut=cut,\n                                                  weights=dens)\n        else:\n            interpTemp = interpolate_to_2d(pos=pos, unit=self.ulength,\n                                           values=temp, bins=bins,\n                                           xrange=xrange, yrange=yrange,\n                                           zrange=zrange, cut=cut,\n                                           weights=dens)\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im = ax.imshow(np.log10(interpTemp), vmin=self.vmin, vmax=self.vmax,\n                       extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                       origin='lower', cmap='afmhot')\n        ax.text(0.95, 0.05, f'{time:.2f} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none',\n                      'boxstyle': 'round', 'alpha': 0.5})\n        ax.set_aspect('equal')\n        ax.set_xlabel(f'$x$ [{self.ulengthselect}]')\n        ax.set_ylabel(f'$y$ [{self.ulengthselect}]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im, cax=cax, label=r'$\\log_{10}(T \\ [\\mathrm{K}])$')\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def resolution(self, bins=100, levels=5, smooth=0, funcname='resol'):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        h, iu = read_hdf5(file=self.file)\n        mass = h['PartType0']['Masses'] * iu['umass']\n        dens = h['PartType0']['Density'] * iu['udens']\n        radius = ((3*mass) / (4*np.pi*dens))**(1/3)\n\n        # 2D Histograms:\n        H0, xedges0, yedges0 = np.histogram2d(np.log10(dens),\n                                              np.log10(radius / const['pc']),\n                                              bins=bins)\n        H1, xedges1, yedges1 = np.histogram2d(np.log10(dens),\n                                              np.log10(mass / const['Msol']),\n                                              bins=bins)\n\n        # Gaussian filter:\n        if smooth &gt; 0:\n            H0 = gaussian_filter(H0, sigma=smooth)\n            H1 = gaussian_filter(H1, sigma=smooth)\n\n        # Log scale:\n        with np.errstate(divide='ignore'):\n            H0 = np.log10(H0.T)\n            H1 = np.log10(H1.T)\n\n        # Figure:\n        fig, ax = plt.subplots(2, 1, figsize=(7, 7), sharex=True)\n        fig.subplots_adjust(left=0.15, right=0.85, bottom=0.15, top=0.95,\n                            wspace=0, hspace=0)\n\n        # Density vs Radius:\n        cf = ax[0].contourf(H0, levels=levels, extent=(xedges0[0], xedges0[-1],\n                            yedges0[0], yedges0[-1]), origin='lower',\n                            cmap=configv.cmap['default'])\n        ax[0].set_ylabel(r'$\\log_{10}(r_\\mathrm{cell} \\ [\\mathrm{pc}])$')\n        ax[0].grid()\n        ax[0].set_xlim(self.xlim)\n\n        cax = ax[0].inset_axes([1, -1, 0.05, 2])\n        fig.colorbar(cf, cax=cax, label=r'$\\log_{10}(N_\\mathrm{cells})$')\n\n        # Density vs Mass:\n        ax[1].contourf(H1, levels=levels, extent=(xedges1[0], xedges1[-1],\n                       yedges1[0], yedges1[-1]), origin='lower',\n                       cmap=configv.cmap['default'])\n        ax[1].set_ylabel(r'$\\log_{10}(M_\\mathrm{cell} \\ [\\mathrm{M}_\\odot])$')\n        ax[1].set_xlabel(r'$\\log_{10}(\\rho_\\mathrm{cell}$' +\n                         r' $[\\mathrm{g} \\ \\mathrm{cm}^{-3}])$')\n        ax[1].grid()\n\n        # Jeans length:\n        ax[0].autoscale(False)\n        xlim = ax[0].get_xlim()\n        xlim = np.array(xlim)\n\n        mu = (1 + 4 * 0.1)\n        jeans10 = np.sqrt((15 * const['kb'] * 10) / (4 * np.pi * const['G'] *\n                                                     mu * const['mp'] *\n                                                     10**(xlim)))\n        jeans100 = np.sqrt((15 * const['kb'] * 100) / (4 * np.pi * const['G'] *\n                                                       mu * const['mp'] *\n                                                       10**(xlim)))\n\n        ax[0].plot(xlim, np.log10(jeans10 / const['pc']), c='k', ls='--',\n                   lw=1, alpha=0.8, label=r'$\\Lambda_J$($T=10$ K)')\n        ax[0].plot(xlim, np.log10(jeans100 / const['pc']), c='k', ls='--',\n                   lw=1, alpha=0.8, label=r'$\\Lambda_J$($T=100$ K)')\n        labelLines(ax[0].get_lines(), xvals=[-24, -24], ha='center',\n                   fontsize=14)\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def stellar(self, axis='z', rotate=0, bins=100, bhfocus=False,\n                funcname='stellar', xrange=None, yrange=None, zrange=None,\n                box=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print(f'  * Reading data of {self.file}')\n        h, iu = read_hdf5(file=self.file)\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n\n        # Stellar component:\n        pos_disk = h['PartType2']['Coordinates'] * iu['ulength'] / const['kpc']\n        mass_disk = h['PartType2']['Masses'] * iu['umass'] / const['Msol']\n\n        pos = pos_disk\n        mass = mass_disk\n\n        print('  * Generating a stellar surface density map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Bins in x and y:\n        xbins, dx = np.linspace(xrange[0], xrange[1], bins, retstep=True)\n        ybins, dy = np.linspace(yrange[0], yrange[1], bins, retstep=True)\n\n        # Remove particles outside the zrange:\n        mask = (pos[:, 2] &gt; np.min(zrange)) * (pos[:, 2] &lt; np.max(zrange))\n        pos, mass = pos[mask], mass[mask]\n\n        # Rotation of particle positions:\n        pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos, bhfocus=bhfocus)\n\n        # Histogram 2D:\n        H, xedges, yedges = np.histogram2d(pos[:, 0], pos[:, 1],\n                                           bins=(xbins, ybins), weights=mass)\n        with np.errstate(divide='ignore'):\n            H = np.log10(H.T / (dx * dy))\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im = ax.imshow(H, origin='lower',\n                       extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],\n                       vmin=self.vmin, vmax=self.vmax, cmap='bone')\n        ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                      'boxstyle': 'round'})\n        bone = mpl.colormaps['bone']\n        ax.set_facecolor(bone(0))\n        ax.set_aspect('equal')\n        ax.set_xlabel('$x$ [kpc]')\n        ax.set_ylabel('$y$ [kpc]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im, cax=cax, label=r'$\\log_{10}$($\\Sigma_\\star$'\n                     + r' [M$_\\odot$ kpc$^{-2}$])')\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def darkmatter(self, axis='z', rotate=0, bins=100, bhfocus=False,\n                   funcname='dm', xrange=None, yrange=None, zrange=None,\n                   box=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print(f'  * Reading data of {self.file}')\n        h, iu = read_hdf5(file=self.file)\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n\n        # DM component:\n        pos = h['PartType1']['Coordinates'] * iu['ulength'] / const['kpc']\n        if 'Masses' in h['PartType1']:\n            mass = h['PartType1']['Masses'] * iu['umass'] / const['Msol']\n        else:\n            mass = np.full(len(pos), h['Header'].attrs['MassTable'][1]\n                           * iu['umass'] / const['Msol'])\n\n        print('  * Generating a dark matter surface density map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Bins in x and y:\n        xbins, dx = np.linspace(xrange[0], xrange[1], bins, retstep=True)\n        ybins, dy = np.linspace(yrange[0], yrange[1], bins, retstep=True)\n\n        # Remove particles outside the zrange:\n        mask = (pos[:, 2] &gt; np.min(zrange)) * (pos[:, 2] &lt; np.max(zrange))\n        pos, mass = pos[mask], mass[mask]\n\n        # Rotation of particle positions:\n        pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos, bhfocus=bhfocus)\n\n        # Histogram 2D:\n        H, xedges, yedges = np.histogram2d(pos[:, 0], pos[:, 1],\n                                           bins=(xbins, ybins), weights=mass)\n        with np.errstate(divide='ignore'):\n            H = np.log10(H.T / (dx * dy))\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 4), layout='constrained')\n        im = ax.imshow(H, origin='lower',\n                       extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],\n                       vmin=self.vmin, vmax=self.vmax, cmap='magma')\n        ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                      'boxstyle': 'round'})\n        bone = mpl.colormaps['magma']\n        ax.set_facecolor(bone(0))\n        ax.set_aspect('equal')\n        ax.set_xlabel('$x$ [kpc]')\n        ax.set_ylabel('$y$ [kpc]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im, cax=cax, label=r'$\\log_{10}$($\\Sigma_\\star$'\n                     + r' [M$_\\odot$ kpc$^{-2}$])')\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def star_formation(self, axis='z', rotate=0, bins=100, sfb=100,\n                       interpolation='kdtree', bhfocus=False, funcname='sf',\n                       xrange=None, yrange=None, zrange=None, box=None,\n                       cut=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print(f'  * Reading data of {self.file}')\n        h, iu = read_hdf5(file=self.file)\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        pos_gas = h['PartType0']['Coordinates'] * iu['ulength'] / const['kpc']\n        dens_gas = h['PartType0']['Density'] * iu['udens']\n        pos_stars = (h['PartType4']['Coordinates'] * iu['ulength']\n                     / const['kpc'])\n        mass_stars = h['PartType4']['Masses'] * iu['umass'] / const['Msol']\n        time_stars = (h['PartType4']['StellarFormationTime'] * iu['utime']\n                      / const['Myr'])\n\n        print('  * Generating a star formation rate surface density map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos_gas -= bh\n            pos_stars -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Rotation of particle positions:\n        pos_gas = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                   pos=pos_gas, bhfocus=bhfocus)\n        pos_stars = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                     pos=pos_stars, bhfocus=bhfocus)\n\n        # Interpolation:\n        if interpolation == 'kdtree':\n            interpDens = interpolate_to_2d_kdtree(pos=pos_gas,\n                                                  unit=self.ulength,\n                                                  values=dens_gas, bins=bins,\n                                                  xrange=xrange, yrange=yrange,\n                                                  zrange=zrange, cut=cut)\n        else:\n            interpDens = interpolate_to_2d(pos=pos_gas, unit=self.ulength,\n                                           values=dens_gas, bins=bins,\n                                           xrange=xrange, yrange=yrange,\n                                           zrange=zrange, cut=cut)\n\n        # Star formation surface density:\n        mask_sf = (time - time_stars &lt; 10)\n        xbins, dx = np.linspace(np.min(xrange), np.max(xrange), sfb,\n                                retstep=True)\n        ybins, dy = np.linspace(np.min(yrange), np.max(yrange), sfb,\n                                retstep=True)\n        H = np.histogram2d(pos_stars[:, 0][mask_sf], pos_stars[:, 1][mask_sf],\n                           bins=[xbins, ybins], weights=mass_stars[mask_sf])[0]\n        with np.errstate(divide='ignore'):\n            H = np.log10(H.T/(dx * dy) / (10 * 1e6))\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im_gas = ax.imshow(np.log10(interpDens), origin='lower',\n                           extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                           vmin=self.vmin, vmax=self.vmax, cmap='Greys')\n        ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none',\n                      'alpha': 0.5, 'boxstyle': 'round'})\n        ax.set_aspect('equal')\n        ax.set_xlabel('$x$ [kpc]')\n        ax.set_ylabel('$y$ [kpc]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im_gas, cax=cax, label=r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                     + r' $[\\mathrm{g} \\ \\mathrm{cm}^{-2}])$')\n\n        im_sf = ax.imshow(H, origin='lower', cmap='winter',\n                          extent=(xrange[0], xrange[1], yrange[0], yrange[1]))\n        cax = ax.inset_axes([0.02, 0.94, 0.7, 0.04])\n        cb = fig.colorbar(im_sf, cax=cax, orientation='horizontal',\n                          location='bottom')\n        cb.set_label(label=r'$\\log_{10}(\\Sigma_\\mathrm{SFR}$'\n                     + r' $[\\mathrm{M}_\\odot$ yr$^{-1}$'\n                     + f'{self.ulengthselect}' + '$^{-2}$' + '])', size=12)\n        cb.ax.tick_params(labelsize=12)\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def stellar_age(self, axis='z', rotate=0, bins=100, age=100,\n                    interpolation='kdtree', bhfocus=False, funcname='sa',\n                    xrange=None, yrange=None, zrange=None, box=None, cut=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print(f'  * Reading data of {self.file}')\n        h, iu = read_hdf5(file=self.file)\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        pos_gas = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n        dens_gas = h['PartType0']['Density'] * iu['udens']\n        pos_stars = (h['PartType4']['Coordinates'] * iu['ulength']\n                     / self.ulength)\n        time_stars = (h['PartType4']['StellarFormationTime'] * iu['utime']\n                      / const['Myr'])\n\n        print('  * Generating a map highlighting the stellar age of newly' +\n              ' formed star particles')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos_gas -= bh\n            pos_stars -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Rotation of particle positions:\n        pos_gas = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                   pos=pos_gas, bhfocus=bhfocus)\n        pos_stars = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                     pos=pos_stars, bhfocus=bhfocus)\n\n        # Interpolation:\n        if interpolation == 'kdtree':\n            interpDens = interpolate_to_2d_kdtree(pos=pos_gas,\n                                                  unit=self.ulength,\n                                                  values=dens_gas, bins=bins,\n                                                  xrange=xrange, yrange=yrange,\n                                                  zrange=zrange, cut=cut)\n        else:\n            interpDens = interpolate_to_2d(pos=pos_gas, unit=self.ulength,\n                                           values=dens_gas, bins=bins,\n                                           xrange=xrange, yrange=yrange,\n                                           zrange=zrange, cut=cut)\n\n        # Stars:\n        mask = ((pos_stars[:, 0] &gt; xrange[0]) * (pos_stars[:, 0] &lt; xrange[1])\n                * (pos_stars[:, 1] &gt; yrange[0]) * (pos_stars[:, 1] &lt; yrange[1])\n                * (pos_stars[:, 2] &gt; zrange[0]) * (pos_stars[:, 2] &lt; zrange[1])\n                * (np.abs(time - time_stars) &lt; age))\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im_gas = ax.imshow(np.log10(interpDens), origin='lower', cmap='Greys',\n                           extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                           vmin=self.vmin, vmax=self.vmax)\n        ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                      'boxstyle': 'round'})\n        ax.set_aspect('equal')\n        ax.set_xlabel('$x$ [kpc]')\n        ax.set_ylabel('$y$ [kpc]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im_gas, cax=cax, label=r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                     + r' $[\\mathrm{g} \\ \\mathrm{cm}^{-2}])$')\n\n        time_diff = np.abs(time - time_stars[mask])\n        im_sa = ax.scatter(pos_stars[:, 0][mask], pos_stars[:, 1][mask],\n                           c=time_diff, s=10, marker='.', cmap='viridis',\n                           vmin=0, vmax=np.min([age, np.max(time_diff)]))\n        cax = ax.inset_axes([0.02, 0.94, 0.7, 0.04])\n        cb = fig.colorbar(im_sa, cax=cax, orientation='horizontal',\n                          location='bottom')\n        cb.set_label(label='Stellar age [Myr]', size=12)\n        cb.ax.tick_params(labelsize=12)\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def star_formation_rate(self, funcname='sfr'):\n        '''TODO\n        '''\n        # Read the data:\n        print(f'  * Reading data of {self.file}')\n        h, iu = read_hdf5(file=self.file)\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        pos_stars = (h['PartType4']['Coordinates'] * iu['ulength']\n                     / const['kpc'])\n        mass_stars = h['PartType4']['Masses'] * iu['umass'] / const['Msol']\n        time_stars = (h['PartType4']['StellarFormationTime'] * iu['utime']\n                      / const['Myr'])\n\n        bins = np.arange(0, time+10, 10)\n        bins[-1] = time\n        SFR, bin_edges = np.histogram(time_stars, bins=bins,\n                                      weights=mass_stars)\n        bin_mids = (bin_edges[:-1] + bin_edges[1:]) / 2\n        bin_widths = (bin_edges[1:] - bin_edges[:-1])\n        SFR = np.log10(SFR / (bin_widths * 1e6))\n\n        fig, ax = plt.subplots(figsize=(6, 4.5), layout='constrained')\n        ax.plot(bin_mids, SFR, lw=2)\n        ax.set_xlabel('Time [Myr]')\n        ax.set_ylabel(r'$\\log_{10}(\\text{SFR}$' +\n                      r'$ \\ [\\text{M}_\\odot \\ \\text{yr}^{-1}])$')\n        ax.grid()\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def black_hole_evolution(self, vcr, funcname='bhevol'):\n        '''\n        Description: TODO\n        '''\n        # Snapshot range:\n        file_list = os.listdir()\n        snap_list = [i for i in file_list if 'snap_' in i]\n        snap_list = [i for i in snap_list if 'sink_' not in i]\n        snum_list = [int(i[5:-5]) for i in snap_list]\n        n = np.min(snum_list)\n        N = int(self.file[len(self.file)-8:-5])\n\n        # Obtain the black hole data:\n        BHData = get_black_hole_data(output_dir=os.getcwd(), n=n, N=N,\n                                     vcr=vcr)\n\n        # Collection of plots:\n        ls = '-'\n        lw = 2\n        c = 'tab:blue'\n        fs = 14\n\n        fig, ax = plt.subplots(2, 5, figsize=(14, 5.5), sharex=True,\n                               layout='constrained')\n\n        # Sink mass:\n        ax[0, 0].plot(BHData['Time'], np.log10(BHData['MassSink']),\n                      ls=ls, lw=lw, c=c)\n        ax[0, 0].set_title(r'$\\log_{10}(M_\\mathrm{Sink}$' +\n                           r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n        ax[0, 0].set_xlim(0, np.max(BHData['Time']))\n        ax[0, 0].grid()\n\n        # BH growth:\n        ax[0, 1].plot(BHData['Time'], np.log10(BHData['MassBH']),\n                      ls=ls, lw=lw, c=c)\n        ax[0, 1].set_title(r'$\\log_{10}(M_\\mathrm{BH} \\ [\\mathrm{M}_\\odot])$',\n                           fontsize=fs)\n        ax[0, 1].grid()\n\n        # Gas reservoir:\n        GasReserv = np.array(BHData['MassReserv'])\n        GasReserv[GasReserv &lt;= 0] = 1e-99\n        ax[0, 2].plot(BHData['Time'], np.log10(GasReserv), ls=ls, lw=lw, c=c)\n        ax[0, 2].set_title(r'$\\log_{10}(M_\\mathrm{Reserv}$' +\n                           r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n        ax[0, 2].set_ylim(-9, 5)\n        ax[0, 2].grid()\n\n        # Gas accretion disk:\n        AccDisk = np.array(BHData['MassDisk'])\n        AccDisk[AccDisk &lt;= 0] = 1e-99\n        ax[0, 3].plot(BHData['Time'], np.log10(AccDisk), ls=ls, lw=lw, c=c)\n        ax[0, 3].set_title(r'$\\log_{10}(M_\\mathrm{Disk}$' +\n                           r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n        ax[0, 3].set_ylim(-9, 5)\n        ax[0, 3].grid()\n\n        # Relative error:\n        mass_diff = ((np.array(BHData['MassSink'])\n                      - np.array(BHData['MassReserv'])\n                      - np.array(BHData['MassDisk'])\n                      - np.array(BHData['MassBH']))\n                     / np.array(BHData['MassSink']))\n        ax[0, 4].plot(BHData['Time'], mass_diff, lw=lw, c=c)\n        ax[0, 4].set_title('Relative Error', fontsize=fs)\n        ax[0, 4].set_yscale('linear')\n        ax[0, 4].grid()\n\n        # Sink accretion rate:\n        FracEddSink = np.array(BHData['MdotSink'])/np.array(BHData['MdotEdd'])\n        FracEddSink[FracEddSink &lt;= 0] = 1e-99\n        ax[1, 0].stairs(np.log10(FracEddSink), BHData['Time'], baseline=-99,\n                        lw=lw, color=c, alpha=0.8, fill=True, rasterized=True)\n        ax[1, 0].axhline(0, c='k', ls=':', lw=1, zorder=9)\n        ax[1, 0].axhline(np.log10(0.02), c='k', ls='--', lw=1, zorder=9)\n        ax[1, 0].set_xlabel('Time [Myr]')\n        ax[1, 0].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{Sink}/$' +\n                           r'$\\dot{M}_\\mathrm{Edd})$', fontsize=fs)\n        ax[1, 0].set_ylim(-9, 1)\n        ax[1, 0].grid()\n\n        MdotSink = np.array(BHData['MdotSink'])\n        MdotSink[MdotSink &lt;= 0] = 1e-99\n        ax[1, 1].stairs(np.log10(MdotSink), BHData['Time'], baseline=-99,\n                        lw=lw, color=c, alpha=0.8, fill=True, rasterized=True)\n        ax[1, 1].set_xlabel('Time [Myr]')\n        ax[1, 1].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{Sink}$' +\n                           r'$ [\\mathrm{M}_\\odot \\ \\mathrm{yr}^{-1}])$',\n                           fontsize=fs)\n        ax[1, 1].set_ylim(-9, -3)\n        ax[1, 1].grid()\n\n        # BH Accretion rate:\n        FracEddBH = np.array(BHData['MdotBH']) / np.array(BHData['MdotEdd'])\n        FracEddBH[FracEddBH &lt;= 0] = 1e-99\n        ax[1, 2].plot(BHData['TimeMid'], np.log10(FracEddBH), lw=lw, c=c,\n                      zorder=10)\n        ax[1, 2].axhline(0, c='k', ls=':', lw=1, zorder=9)\n        ax[1, 2].axhline(np.log10(0.02), c='k', ls='--', lw=1, zorder=9)\n        ax[1, 2].set_xlabel('Time [Myr]')\n        ax[1, 2].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{BH}/$' +\n                           r'$\\dot{M}_\\mathrm{Edd})$', fontsize=fs)\n        ax[1, 2].set_ylim(-9, 1)\n        ax[1, 2].grid()\n\n        MdotBH = np.array(BHData['MdotBH'])\n        MdotBH[MdotBH &lt;= 0] = 1e-99\n        ax[1, 3].plot(BHData['TimeMid'], np.log10(MdotBH), lw=2, c=c,\n                      zorder=10)\n        ax[1, 3].set_xlabel('Time [Myr]')\n        ax[1, 3].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{BH}$' +\n                           r' [M$_\\odot$ yr$^{-1}$])', fontsize=fs)\n        ax[1, 3].set_ylim(-9, -3)\n        ax[1, 3].grid()\n\n        # Circularisation radius:\n        if len(BHData['CircRadius']) &gt; 0:\n            ax[1, 4].plot(BHData['Time'], BHData['CircRadius'], lw=lw, c=c)\n            ax[1, 4].set_xlabel('Time [Myr]')\n            ax[1, 4].set_title(r'$R_\\mathrm{circ}$ [left: pc, right: ' +\n                               r'$r_\\mathrm{s}$]', fontsize=fs)\n            ax[1, 4].set_yscale('linear')\n            ax[1, 4].grid()\n\n            ax2 = ax[1, 4].twinx()\n            rs = (2 * const['G'] * BHData['MassBH'][0] * const['Msol'] /\n                  np.power(const['c'], 2))\n            Rcirc = np.array(BHData['CircRadius']) * const['pc'] / rs\n            ax2.plot(BHData['Time'], Rcirc, lw=lw, c=c)\n            ax2.set_yscale('linear')\n        else:\n            ax[1, 4].set_visible(False)\n\n        # Save:\n        print('  * Figure generated successfully!')\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def ffmpeg(self, framedir, skip):\n        '''\n        Description: TODO\n        '''\n\n        if os.path.isdir(f'./vframes/{framedir}'):\n            fnr = 0\n            if skip:\n                fnr += skip\n            frame = '000'[:3-len(str(fnr))] + str(fnr)\n            print(f'  * Searching for {framedir} frames')\n            while os.path.isfile(f'./vframes/{framedir}/' +\n                                 f'{framedir}_{frame}.png'):\n                fnr += 1\n                frame = '000'[:3-len(str(fnr))] + str(fnr)\n            fnr_print = fnr\n            if skip:\n                fnr_print -= skip\n            print(f'  * Found {fnr_print} frames!')\n\n        start = 0\n        if skip:\n            start += skip\n        file_split = self.file.split('.')\n        vframes = int(file_split[0][-3:])\n        if not skip:\n            vframes += 1\n        if vframes &gt; fnr:\n            print('  * Trying to generate a movie up to a given snapshot' +\n                  ' without the neccessary frames needed to do so,' +\n                  ' therefore, exiting the ffmpeg function')\n            return None\n        fps = 15\n        res_width = 1920\n        res_height = 1080\n\n        f = os.system(f'ffmpeg -r {fps} -f image2 -y' +\n                      f' -s {res_width}x{res_height}' +\n                      f' -start_number {start}' +\n                      f' -i {os.getcwd()}/vframes/{framedir}/' +\n                      f'{framedir}_%03d.png' +\n                      f' -vframes {vframes}' +\n                      ' -vcodec libx264' +\n                      ' -vf \"pad=ceil(iw/2)*2:ceil(ih/2)*2:color=white\"' +\n                      ' -crf 25' +\n                      ' -pix_fmt yuv420p' +\n                      f' {os.getcwd()}/{framedir}.mp4' +\n                      ' &gt; ffmpeg.out 2&gt; ffmpeg.err')\n        if f == 0:\n            print('  * Film generated successfully!')\n        else:\n            print('  * Error: Something went wrong, please check the ffmpeg' +\n                  ' output/error file')\n\n        return None\n</code></pre>"},{"location":"terminal_plot/#vatpy.terminal_plot.TerminalPlot.info","title":"<code>info()</code>","text":"<p>Function to provide some general information about the given snapshot, such as the physical time, size of the simulation domain, number of particles, etc.</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def info(self):\n    '''Function to provide some general information about the given\n    snapshot, such as the physical time, size of the simulation domain,\n    number of particles, etc.\n    '''\n    # Read the data:\n    h, iu = read_hdf5(file=self.file)\n\n    time_int = h['Header'].attrs['Time']\n    time_phys = time_int * iu['utime'] / const['Myr']\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n    numpart = h['Header'].attrs['NumPart_ThisFile']\n\n    print('  * Snapshot information')\n    print(f'  | Time (internal) : {round(time_int, 2)}')\n    print(f'  | Time (physical) : {round(time_phys, 2)} Myr')\n    print(f'  | BoxSize       : {round(boxsize, 2)} kpc')\n    print('  |')\n    print('  | Number of particles')\n    print(f'  | PartType0 (gas)      : {numpart[0]}')\n    print(f'  | PartType1 (halo)     : {numpart[1]}')\n    print(f'  | PartType2 (disk)     : {numpart[2]}')\n    print(f'  | PartType3 (bulge)    : {numpart[3]}')\n    print(f'  | PartType4 (stars)    : {numpart[4]}')\n    print(f'  | PartType5 (bndry)    : {numpart[5]}')\n    print(f'  | Total Particle Count : {np.sum(numpart)}')\n    print('  | ')\n\n    mt = h['Header'].attrs['MassTable']\n    print('  | Table of Particle Masses [i.u.]')\n    print(f'  | {mt[0]}, {mt[1]}, {mt[2]}, {mt[3]}, {mt[4]}, {mt[5]}')\n\n    if numpart[4] &gt; 0:\n        print('  |')\n        print('  * Star particles detected')\n        print(f'  | Total number of stars: {numpart[4]}')\n        sne = h['PartType4']['NumberOfSupernovae'][:]\n        stars = h['PartType4']['StellarMasses'][:]\n        print(f'  | Total number of OB stars: {np.sum(sne)}')\n        print(f'  | Max mass of star particles: {np.max(stars)}')\n\n    if numpart[5] == 1:\n        print('  |')\n        print('  * A central BH detected')\n        Pbh = h['PartType5']['Coordinates'][0]\n        print(f'  | Coordinates [i.u.] : ({Pbh[0]}, {Pbh[1]}, {Pbh[2]})')\n        Vbh = h['PartType5']['Velocities'][0]\n        print(f'  | Velocities [i.u.]  : ({Vbh[0]}, {Vbh[1]}, {Vbh[2]})')\n        Mbh = h['PartType5']['Masses'][0] * iu['umass'] / const['Msol']\n        print(f'  | Mass [i.u.]        : {Mbh}')\n        IDbh = h['PartType5']['ParticleIDs'][0]\n        print(f'  | Particle ID        : {IDbh}')\n    elif numpart[5] &gt; 1:\n        print('  |')\n        print('  * Multiple BHs detected!')\n\n    print('  |')\n\n    return None\n</code></pre>"},{"location":"terminal_plot/#vatpy.terminal_plot.TerminalPlot.density","title":"<code>density(axis='z', rotate=0, quantity='mass', bins=100, interpolation='kdtree', bhfocus=False, funcname='dens', xrange=None, yrange=None, zrange=None, box=None, cut=None)</code>","text":"<p>Function to generate a column density map of the gas surface density, with the possibility to also show the column density of various chemical species, such as HI, HII, and H2. This is achieved by first interpolating the selected gas quantity onto a grid, and later doing a sum along the line-of-sight.</p> <p>Parameters:</p> Name Type Description Default <code>axis</code> <code>str</code> <p>Rotation axis</p> <code>'z'</code> <code>rotate</code> <code>float</code> <p>Amount of rotation</p> <code>0</code> <code>quantity</code> <code>str</code> <p>Gas quantity to visualise             (options: mass/n/HI/HII/H2/CO/He/e)</p> <code>'mass'</code> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def density(self, axis='z', rotate=0, quantity='mass', bins=100,\n            interpolation='kdtree', bhfocus=False, funcname='dens',\n            xrange=None, yrange=None, zrange=None, box=None, cut=None):\n    '''Function to generate a column density map of the gas surface\n    density, with the possibility to also show the column density of\n    various chemical species, such as HI, HII, and H2. This is achieved by\n    first interpolating the selected gas quantity onto a grid, and later\n    doing a sum along the line-of-sight.\n\n    Args:\n        axis (str): Rotation axis\n        rotate (float): Amount of rotation\n        quantity (str): Gas quantity to visualise\n                        (options: mass/n/HI/HII/H2/CO/He/e)\n    '''\n    # Read the data:\n    print(f'  * Reading data of {self.file}')\n    h, iu = read_hdf5(file=self.file)\n    pos = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n    dens = h['PartType0']['Density'] * iu['udens']\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n\n    print('  * Generating a gas surface density map')\n\n    # Centre the data on the black hole:\n    if bhfocus:\n        bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n              / self.ulength)\n        pos -= bh\n\n    # Coordinate ranges:\n    xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                             xrange=xrange, yrange=yrange,\n                                             zrange=zrange,\n                                             bhfocus=bhfocus)\n\n    # Selection of gas quantity:\n    if (quantity != 'mass'):\n        num = number_density(h, iu)\n        dens = num[quantity]\n\n    # Rotation of particle positions:\n    pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                           pos=pos, bhfocus=bhfocus)\n\n    # Interpolation:\n    if interpolation == 'kdtree':\n        interpDens = interpolate_to_2d_kdtree(pos=pos, unit=self.ulength,\n                                              values=dens, bins=bins,\n                                              xrange=xrange, yrange=yrange,\n                                              zrange=zrange, cut=cut)\n    else:\n        interpDens = interpolate_to_2d(pos=pos, unit=self.ulength,\n                                       values=dens, bins=bins,\n                                       xrange=xrange, yrange=yrange,\n                                       zrange=zrange, cut=cut)\n\n    # Plot:\n    fig, ax = plt.subplots(figsize=(8, 6.4))\n    fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                        wspace=0, hspace=0)\n\n    im = ax.imshow(np.log10(interpDens), vmin=self.vmin, vmax=self.vmax,\n                   extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                   origin='lower', cmap=configv.cmap['gas'])\n    if bhfocus:\n        ax.scatter(0, 0, s=40, c='k')\n    ax.text(0.95, 0.05, f'{time:.2f} Myr', color='k',\n            ha='right', va='bottom', transform=ax.transAxes,\n            bbox={'facecolor': 'white', 'edgecolor': 'none',\n                  'boxstyle': 'round', 'alpha': 0.5})\n    ax.set_aspect('equal')\n    ax.set_xlabel(f'$x$ [{self.ulengthselect}]')\n    ax.set_ylabel(f'$y$ [{self.ulengthselect}]')\n    ax.set_xlim(self.xlim)\n    ax.set_ylim(self.ylim)\n\n    # Colorbar:\n    if not cut:\n        dim = 2\n    else:\n        dim = 3\n    cbar_label = {\n        'HII': (r'$\\log_{10}(\\Sigma_{\\mathrm{HII}}$'\n                r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'H2': (r'$\\log_{10}(\\Sigma_{\\mathrm{H}_2}$'\n               r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'HI': (r'$\\log_{10}(\\Sigma_{\\mathrm{HI}}$'\n               r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'CO': (r'$\\log_{10}(\\Sigma_{\\mathrm{CO}}$'\n               r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'He': (r'$\\log_{10}(\\Sigma_{\\mathrm{He}}$'\n               r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'e': (r'$\\log_{10}(\\Sigma_{e^{-}}$'\n              r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'n': (r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n              r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'mass': (r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                 r' $[\\mathrm{g} \\ \\mathrm{cm}^{-%d}])$' % dim)\n    }\n\n    div = make_axes_locatable(ax)\n    cax = div.append_axes('right', size='5%', pad=0)\n    fig.colorbar(im, cax=cax, label=cbar_label[quantity])\n\n    # Save:\n    print('  * Figure generated successfully!')\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    self.display()\n\n    return None\n</code></pre>"},{"location":"terminal_plot/#vatpy.terminal_plot.TerminalPlot.temperature","title":"<code>temperature(axis='z', rotate=0, bins=100, interpolation='kdtree', bhfocus=False, funcname='temp', xrange=None, yrange=None, zrange=None, box=None, cut=None)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def temperature(self, axis='z', rotate=0, bins=100, interpolation='kdtree',\n                bhfocus=False, funcname='temp', xrange=None, yrange=None,\n                zrange=None, box=None, cut=None):\n    '''\n    Description: TODO\n    '''\n    # Read the data:\n    print(f'  * Reading data of {self.file}')\n    h, iu = read_hdf5(file=self.file)\n    pos = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n    dens = h['PartType0']['Density'] * iu['udens']\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n    temp = temperature(h, iu)\n\n    print('  * Generating a gas temperature (density-weighted) map')\n\n    # Centre the data on the black hole:\n    if bhfocus:\n        bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n              / self.ulength)\n        pos -= bh\n\n    # Coordinate ranges:\n    xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                             xrange=xrange, yrange=yrange,\n                                             zrange=zrange,\n                                             bhfocus=bhfocus)\n\n    # Rotation of particle positions:\n    pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                           pos=pos, bhfocus=bhfocus)\n\n    # Interpolation:\n    if interpolation == 'kdtree':\n        interpTemp = interpolate_to_2d_kdtree(pos=pos, unit=self.ulength,\n                                              values=temp, bins=bins,\n                                              xrange=xrange, yrange=yrange,\n                                              zrange=zrange, cut=cut,\n                                              weights=dens)\n    else:\n        interpTemp = interpolate_to_2d(pos=pos, unit=self.ulength,\n                                       values=temp, bins=bins,\n                                       xrange=xrange, yrange=yrange,\n                                       zrange=zrange, cut=cut,\n                                       weights=dens)\n\n    # Plot:\n    fig, ax = plt.subplots(figsize=(8, 6.4))\n    fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                        wspace=0, hspace=0)\n\n    im = ax.imshow(np.log10(interpTemp), vmin=self.vmin, vmax=self.vmax,\n                   extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                   origin='lower', cmap='afmhot')\n    ax.text(0.95, 0.05, f'{time:.2f} Myr', color='k',\n            ha='right', va='bottom', transform=ax.transAxes,\n            bbox={'facecolor': 'white', 'edgecolor': 'none',\n                  'boxstyle': 'round', 'alpha': 0.5})\n    ax.set_aspect('equal')\n    ax.set_xlabel(f'$x$ [{self.ulengthselect}]')\n    ax.set_ylabel(f'$y$ [{self.ulengthselect}]')\n    ax.set_xlim(self.xlim)\n    ax.set_ylim(self.ylim)\n\n    div = make_axes_locatable(ax)\n    cax = div.append_axes('right', size='5%', pad=0)\n    fig.colorbar(im, cax=cax, label=r'$\\log_{10}(T \\ [\\mathrm{K}])$')\n\n    # Save:\n    print('  * Figure generated successfully!')\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"}]}
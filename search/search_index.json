{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Vatpy","text":"<p>Vatpy (Visualisation of Arepo in the Terminal using PYthon) is a light-weight, highly customisable, visualisation tool-kit for astrophysical simulations performed using the Arepo code (Springel 2010). </p> <p>Many of its functionalities can be generally applied to simulations made by Arepo (as long as the output is in HDF5-format), however, more specific capabilities,  such as creating visual maps of the gas chemistry, is at the moment only adapted to simulations run using the ArepoNoctua numerical framework (Petersson et al. 2025).</p> <p></p>"},{"location":"contact/","title":"Contact details","text":""},{"location":"docstrings/","title":"Source code","text":"<p>Description: File containing the TerminalPlot class. Authour(s): Jonathan Petersson Last updated: 2025-05-07</p>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot","title":"<code>TerminalPlot</code>","text":"Class to make simple, but informative, visual plots of Arepo <p>snapshots, directly in the terminal (or notebook). Most importantly, it contains funtions to generate column density maps of the gas surface density, as well column density maps of various chemical species, such as HI, HII, and H2. The class also contains functions to inspect the surface density of dark matter and stellar components. For more details, see each function's individual description.</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>class TerminalPlot:\n    '''\n    TerminalPlot: Class to make simple, but informative, visual plots of Arepo\n                  snapshots, directly in the terminal (or notebook). Most\n                  importantly, it contains funtions to generate column density\n                  maps of the gas surface density, as well column density maps\n                  of various chemical species, such as HI, HII, and H2. The\n                  class also contains functions to inspect the surface density\n                  of dark matter and stellar components. For more details, see\n                  each function's individual description.\n    '''\n    def __init__(self, file, style=configv.mplstyle,\n                 savepath=f'{os.getcwd()}/vplots/', savename=None,\n                 saveformat='png', vmin=None, vmax=None, xlim=None, ylim=None,\n                 ulengthselect=configv.unit_for_length, show=True):\n\n        print(f'  * Setting up environment to analyse {file}')\n\n        # Variables:\n        self.file = file\n        self.savepath = savepath\n        self.savename = savename\n        self.saveformat = saveformat\n        self.vmin, self.vmax = vmin, vmax\n        self.xlim, self.ylim = xlim, ylim\n        self.show = show\n\n        # Mpl style:\n        self.style = style\n        plt.style.use(f'{configv.homedir}/vatpy/mpl/{self.style}.mplstyle')\n\n        # Unit selection:\n        self.ulengthselect = ulengthselect\n        if self.ulengthselect == 'kpc':\n            self.ulength = const['kpc']\n        elif self.ulengthselect == 'pc':\n            self.ulength = const['pc']\n        else:\n            self.ulength = 1\n\n    ##########################################################################\n    ##########################################################################\n    def get_ranges(self, boxsize, box, xrange, yrange, zrange, bhfocus):\n        '''\n        Description: Function to get x, y, and z ranges.\n        '''\n        # Determine the coordinate ranges:\n        if not box:\n            if not xrange:\n                if bhfocus:\n                    xrange = (-boxsize/2, boxsize/2)\n                else:\n                    xrange = (0, boxsize)\n            if not yrange:\n                if bhfocus:\n                    yrange = (-boxsize/2, boxsize/2)\n                else:\n                    yrange = (0, boxsize)\n            if not zrange:\n                if bhfocus:\n                    zrange = (-boxsize/2, boxsize/2)\n                else:\n                    zrange = (0, boxsize)\n        else:\n            xrange = (box[0], box[1])\n            yrange = (box[0], box[1])\n            zrange = (box[0], box[1])\n\n        return xrange, yrange, zrange\n\n    def do_rotation(self, boxsize, axis, rotate, pos, bhfocus):\n        '''\n        Description: Function to rotate the position of particles.\n        '''\n        # If applicable, rotate the position of particles:\n        if rotate != 0:\n            rotation = Rotation.from_euler(axis, rotate, degrees=True)\n            if bhfocus:\n                pos = rotation.apply(pos)\n            else:\n                pos = rotation.apply(pos - boxsize/2)\n                pos += boxsize/2\n\n        return pos\n\n    def save(self, fig, funcname):\n        '''\n        Description: Function to save figures.\n        '''\n        # Figure name:\n        filestr = self.file.split('.')\n        figname = f'{funcname}_{filestr[0]}'\n        if self.savename:\n            figname = self.savename + '_' + filestr[0][-3:]\n        figname += f'.{self.saveformat}'\n\n        # Check if Vatpy plot directory already exists:\n        if os.path.isdir(self.savepath):\n            print('  * Path where to save figure found')\n        else:\n            print('  * Path where to save figure NOT found')\n            print('  * Creating a \\'vplot\\' directory')\n            os.mkdir(f'{os.getcwd()}/vplots/')\n\n        # Save figure:\n        fig.savefig(f'{self.savepath}/{figname}')\n        print('  * Figure saved successfully as')\n        print(f'    - name: {figname}')\n        print(f'    - path: {self.savepath}')\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def info(self):\n        '''\n        Description: Function to provide some general information about the\n                     given snapshot, such as the physical time, size of the\n                     simulation domain, number of particles, etc.\n        '''\n        # Read the data:\n        h, iu = read_hdf5(file=self.file)\n\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n        numpart = h['Header'].attrs['NumPart_ThisFile']\n\n        print('  * Snapshot information')\n        print(f'  | Time    : {round(time, 2)} Myr')\n        print(f'  | BoxSize : {round(boxsize, 2)} kpc')\n        print('  |')\n        print('  | Number of particles')\n        print(f'  | PartType0 (gas)      : {numpart[0]}')\n        print(f'  | PartType1 (halo)     : {numpart[1]}')\n        print(f'  | PartType2 (disk)     : {numpart[2]}')\n        print(f'  | PartType3 (bulge)    : {numpart[3]}')\n        print(f'  | PartType4 (stars)    : {numpart[4]}')\n        print(f'  | PartType5 (bndry)    : {numpart[5]}')\n        print(f'  | Total Particle Count : {np.sum(numpart)}')\n        print('  | ')\n\n        mt = h['Header'].attrs['MassTable']\n        print('  | Table of Particle Masses [i.u.]')\n        print(f'  | {mt[0]}, {mt[1]}, {mt[2]}, {mt[3]}, {mt[4]}, {mt[5]}')\n\n        if numpart[5] == 1:\n            print('  |')\n            print('  * A central BH detected')\n            Pbh = h['PartType5']['Coordinates'][0]\n            print(f'  | Coordinates [i.u.] : ({Pbh[0]}, {Pbh[1]}, {Pbh[2]})')\n            Vbh = h['PartType5']['Velocities'][0]\n            print(f'  | Velocities [i.u.]  : ({Vbh[0]}, {Vbh[1]}, {Vbh[2]})')\n            Mbh = h['PartType5']['Masses'][0] * iu['umass'] / const['Msol']\n            print(f'  | Mass [i.u.]        : {Mbh}')\n            IDbh = h['PartType5']['ParticleIDs'][0]\n            print(f'  | Particle ID        : {IDbh}')\n\n        print('  |')\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def density(self, axis='z', rotate=0, quantity='mass', bins=100,\n                interpolation='kdtree', bhfocus=False, xrange=None,\n                yrange=None, zrange=None, box=None, cut=None):\n        '''\n        Description: Function to generate a column density map of the gas\n                     surface density, with the possibility to also show the\n                     column density of various chemical species, such as HI,\n                     HII, and H2. This is achieved by first interpolating the\n                     selected gas quantity onto a grid, and later doing a sum\n                     along the line-of-sight.\n        '''\n        # Read the data:\n        print(f'  * Reading data of {self.file}')\n        h, iu = read_hdf5(file=self.file)\n        pos = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n        dens = h['PartType0']['Density'] * iu['udens']\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n\n        print('  * Generating a gas surface density map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Selection of gas quantity:\n        if (quantity != 'mass'):\n            num = number_density(h, iu)\n            dens = num[quantity]\n\n        # Rotation of particle positions:\n        pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos, bhfocus=bhfocus)\n\n        # Interpolation:\n        if interpolation == 'kdtree':\n            interpDens = interpolate_to_2d_kdtree(pos=pos, unit=self.ulength,\n                                                  values=dens, bins=bins,\n                                                  xrange=xrange, yrange=yrange,\n                                                  zrange=zrange, cut=cut)\n        else:\n            interpDens = interpolate_to_2d(pos=pos, unit=self.ulength,\n                                           values=dens, bins=bins,\n                                           xrange=xrange, yrange=yrange,\n                                           zrange=zrange, cut=cut)\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im = ax.imshow(np.log10(interpDens), vmin=self.vmin, vmax=self.vmax,\n                       extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                       origin='lower', cmap=configv.cmap['gas'])\n        if bhfocus:\n            ax.scatter(0, 0, s=40, c='k')\n        ax.text(0.95, 0.05, f'{time:.2f} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none',\n                      'boxstyle': 'round', 'alpha': 0.5})\n        ax.set_aspect('equal')\n        ax.set_xlabel(f'$x$ [{self.ulengthselect}]')\n        ax.set_ylabel(f'$y$ [{self.ulengthselect}]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n\n        # Colorbar:\n        if not cut:\n            dim = 2\n        else:\n            dim = 3\n        cbar_label = {\n            'HII': (r'$\\log_{10}(\\Sigma_{\\mathrm{HII}}$'\n                    r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'H2': (r'$\\log_{10}(\\Sigma_{\\mathrm{H}_2}$'\n                   r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'HI': (r'$\\log_{10}(\\Sigma_{\\mathrm{HI}}$'\n                   r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'CO': (r'$\\log_{10}(\\Sigma_{\\mathrm{CO}}$'\n                   r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'He': (r'$\\log_{10}(\\Sigma_{\\mathrm{He}}$'\n                   r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'e': (r'$\\log_{10}(\\Sigma_{e^{-}}$'\n                  r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'n': (r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                  r' $[\\mathrm{cm}^{-%d}])$' % dim),\n            'mass': (r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                     r' $[\\mathrm{g} \\ \\mathrm{cm}^{-%d}])$' % dim)\n        }\n\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im, cax=cax, label=cbar_label[quantity])\n\n        # Save:\n        print('  * Figure generated successfully')\n        funcname = 'dens'\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def temperature(self, axis='z', rotate=0, bins=100, interpolation='kdtree',\n                    bhfocus=False, xrange=None, yrange=None, zrange=None,\n                    box=None, cut=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print('  * Reading data of snapshot')\n        h, iu = read_hdf5(file=self.file)\n        pos = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n        dens = h['PartType0']['Density'] * iu['udens']\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n        temp = temperature(h, iu)\n\n        print('  * Generating a gas temperature (density-weighted) map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Rotation of particle positions:\n        pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos, bhfocus=bhfocus)\n\n        # Interpolation:\n        if interpolation == 'kdtree':\n            interpTemp = interpolate_to_2d_kdtree(pos=pos, unit=self.ulength,\n                                                  values=temp, bins=bins,\n                                                  xrange=xrange, yrange=yrange,\n                                                  zrange=zrange, cut=cut,\n                                                  weights=dens)\n        else:\n            interpTemp = interpolate_to_2d(pos=pos, unit=self.ulength,\n                                           values=temp, bins=bins,\n                                           xrange=xrange, yrange=yrange,\n                                           zrange=zrange, cut=cut,\n                                           weights=dens)\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im = ax.imshow(np.log10(interpTemp), vmin=self.vmin, vmax=self.vmax,\n                       extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                       origin='lower', cmap='afmhot')\n        ax.text(0.95, 0.05, f'{time:.2f} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none',\n                      'boxstyle': 'round', 'alpha': 0.5})\n        ax.set_aspect('equal')\n        ax.set_xlabel(f'$x$ [{self.ulengthselect}]')\n        ax.set_ylabel(f'$y$ [{self.ulengthselect}]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im, cax=cax, label=r'$\\log_{10}(T \\ [\\mathrm{K}])$')\n\n        # Save:\n        print('  * Figure generated successfully')\n        funcname = 'temp'\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def resolution(self, bins=100, levels=5, smooth=0):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        h, iu = read_hdf5(file=self.file)\n        mass = h['PartType0']['Masses'] * iu['umass']\n        dens = h['PartType0']['Density'] * iu['udens']\n        radius = ((3*mass) / (4*np.pi*dens))**(1/3)\n\n        # 2D Histograms:\n        H0, xedges0, yedges0 = np.histogram2d(np.log10(dens),\n                                              np.log10(radius / const['pc']),\n                                              bins=bins)\n        H1, xedges1, yedges1 = np.histogram2d(np.log10(dens),\n                                              np.log10(mass / const['Msol']),\n                                              bins=bins)\n\n        # Gaussian filter:\n        if smooth &gt; 0:\n            H0 = gaussian_filter(H0, sigma=smooth)\n            H1 = gaussian_filter(H1, sigma=smooth)\n\n        # Log scale:\n        with np.errstate(divide='ignore'):\n            H0 = np.log10(H0.T)\n            H1 = np.log10(H1.T)\n\n        # Figure:\n        fig, ax = plt.subplots(2, 1, figsize=(7, 7), sharex=True)\n        fig.subplots_adjust(left=0.15, right=0.85, bottom=0.15, top=0.95,\n                            wspace=0, hspace=0)\n\n        # Density vs Radius:\n        cf = ax[0].contourf(H0, levels=levels, extent=(xedges0[0], xedges0[-1],\n                            yedges0[0], yedges0[-1]), origin='lower',\n                            cmap=configv.cmap['default'])\n        ax[0].set_ylabel(r'$\\log_{10}(r_\\mathrm{cell} \\ [\\mathrm{pc}])$')\n        ax[0].grid()\n        ax[0].set_xlim(self.xlim)\n\n        cax = ax[0].inset_axes([1, -1, 0.05, 2])\n        fig.colorbar(cf, cax=cax, label=r'$\\log_{10}(N_\\mathrm{cells})$')\n\n        # Density vs Mass:\n        ax[1].contourf(H1, levels=levels, extent=(xedges1[0], xedges1[-1],\n                       yedges1[0], yedges1[-1]), origin='lower',\n                       cmap=configv.cmap['default'])\n        ax[1].set_ylabel(r'$\\log_{10}(M_\\mathrm{cell} \\ [\\mathrm{M}_\\odot])$')\n        ax[1].set_xlabel(r'$\\log_{10}(\\rho_\\mathrm{cell}$' +\n                         r' $[\\mathrm{g} \\ \\mathrm{cm}^{-3}])$')\n        ax[1].grid()\n\n        # Jeans length:\n        ax[0].autoscale(False)\n        xlim = ax[0].get_xlim()\n        xlim = np.array(xlim)\n\n        mu = (1 + 4 * 0.1)\n        jeans10 = np.sqrt((15 * self.kb * 10) / (4 * np.pi * self.G * mu *\n                                                 self.mp * 10**(xlim)))\n        jeans100 = np.sqrt((15 * self.kb * 100) / (4 * np.pi * self.G * mu *\n                                                   self.mp * 10**(xlim)))\n\n        ax[0].plot(xlim, np.log10(jeans10 / const['pc']), c='k', ls='--',\n                   lw=1, alpha=0.8, label=r'$\\Lambda_J$($T=10$ K)')\n        ax[0].plot(xlim, np.log10(jeans100 / const['pc']), c='k', ls='--',\n                   lw=1, alpha=0.8, label=r'$\\Lambda_J$($T=100$ K)')\n        labelLines(ax[0].get_lines(), xvals=[-24, -24], ha='center',\n                   fontsize=14)\n\n        # Save:\n        print('  * Figure generated successfully')\n        funcname = 'resol'\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def stellar(self, axis='z', rotate=0, bins=100, bhfocus=False,\n                xrange=None, yrange=None, zrange=None, box=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print('  * Reading data of snapshot')\n        h, iu = read_hdf5(file=self.file)\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n\n        # Stellar component:\n        pos_disk = h['PartType2']['Coordinates'] * iu['ulength'] / const['kpc']\n        mass_disk = h['PartType2']['Masses'] * iu['umass'] / const['Msol']\n\n        pos = pos_disk\n        mass = mass_disk\n\n        print('  * Generating a stellar surface density map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Bins in x and y:\n        xbins, dx = np.linspace(xrange[0], xrange[1], bins, retstep=True)\n        ybins, dy = np.linspace(yrange[0], yrange[1], bins, retstep=True)\n\n        # Remove particles outside the zrange:\n        mask = (pos[:, 2] &gt; np.min(zrange)) * (pos[:, 2] &lt; np.max(zrange))\n        pos, mass = pos[mask], mass[mask]\n\n        # Rotation of particle positions:\n        pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos, bhfocus=bhfocus)\n\n        # Histogram 2D:\n        H, xedges, yedges = np.histogram2d(pos[:, 0], pos[:, 1],\n                                           bins=(xbins, ybins), weights=mass)\n        with np.errstate(divide='ignore'):\n            H = np.log10(H.T / (dx * dy))\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im = ax.imshow(H, origin='lower',\n                       extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],\n                       vmin=self.vmin, vmax=self.vmax, cmap='bone')\n        ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                      'boxstyle': 'round'})\n        bone = mpl.colormaps['bone']\n        ax.set_facecolor(bone(0))\n        ax.set_aspect('equal')\n        ax.set_xlabel('$x$ [kpc]')\n        ax.set_ylabel('$y$ [kpc]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im, cax=cax, label=r'$\\log_{10}$($\\Sigma_\\star$'\n                     + r' [M$_\\odot$ kpc$^{-2}$])')\n\n        # Save:\n        print('  * Figure generated successfully')\n        funcname = 'stellar'\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def darkmatter(self, axis='z', rotate=0, bins=100, bhfocus=False,\n                   xrange=None, yrange=None, zrange=None, box=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print('  * Reading data of snapshot')\n        h, iu = read_hdf5(file=self.file)\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n\n        # DM component:\n        pos = h['PartType1']['Coordinates'] * iu['ulength'] / const['kpc']\n        if 'Masses' in h['PartType1']:\n            mass = h['PartType1']['Masses'] * iu['umass'] / const['Msol']\n        else:\n            mass = np.full(len(pos), h['Header'].attrs['MassTable'][1]\n                           * iu['umass'] / const['Msol'])\n\n        print('  * Generating a dark matter surface density map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Bins in x and y:\n        xbins, dx = np.linspace(xrange[0], xrange[1], bins, retstep=True)\n        ybins, dy = np.linspace(yrange[0], yrange[1], bins, retstep=True)\n\n        # Remove particles outside the zrange:\n        mask = (pos[:, 2] &gt; np.min(zrange)) * (pos[:, 2] &lt; np.max(zrange))\n        pos, mass = pos[mask], mass[mask]\n\n        # Rotation of particle positions:\n        pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos, bhfocus=bhfocus)\n\n        # Histogram 2D:\n        H, xedges, yedges = np.histogram2d(pos[:, 0], pos[:, 1],\n                                           bins=(xbins, ybins), weights=mass)\n        with np.errstate(divide='ignore'):\n            H = np.log10(H.T / (dx * dy))\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 4), layout='constrained')\n        im = ax.imshow(H, origin='lower',\n                       extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],\n                       vmin=self.vmin, vmax=self.vmax, cmap='magma')\n        ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                      'boxstyle': 'round'})\n        bone = mpl.colormaps['magma']\n        ax.set_facecolor(bone(0))\n        ax.set_aspect('equal')\n        ax.set_xlabel('$x$ [kpc]')\n        ax.set_ylabel('$y$ [kpc]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im, cax=cax, label=r'$\\log_{10}$($\\Sigma_\\star$'\n                     + r' [M$_\\odot$ kpc$^{-2}$])')\n\n        # Save:\n        print('  * Figure generated successfully')\n        funcname = 'dm'\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def star_formation(self, axis='z', rotate=0, bins=100, sfb=100,\n                       interpolation='kdtree', bhfocus=False, xrange=None,\n                       yrange=None, zrange=None, box=None, cut=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print('  * Reading data of snapshot')\n        h, iu = read_hdf5(file=self.file)\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        pos_gas = h['PartType0']['Coordinates'] * iu['ulength'] / const['kpc']\n        dens_gas = h['PartType0']['Density'] * iu['udens']\n        pos_stars = (h['PartType4']['Coordinates'] * iu['ulength']\n                     / const['kpc'])\n        mass_stars = h['PartType4']['Masses'] * iu['umass'] / const['Msol']\n        time_stars = (h['PartType4']['StellarFormationTime'] * iu['utime']\n                      / const['Myr'])\n\n        print('  * Generating a star formation rate surface density map')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos_gas -= bh\n            pos_stars -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Rotation of particle positions:\n        pos_gas = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                   pos=pos_gas, bhfocus=bhfocus)\n        pos_stars = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                     pos=pos_stars, bhfocus=bhfocus)\n\n        # Interpolation:\n        if interpolation == 'kdtree':\n            interpDens = interpolate_to_2d_kdtree(pos=pos_gas,\n                                                  unit=self.ulength,\n                                                  values=dens_gas, bins=bins,\n                                                  xrange=xrange, yrange=yrange,\n                                                  zrange=zrange, cut=cut)\n        else:\n            interpDens = interpolate_to_2d(pos=pos_gas, unit=self.ulength,\n                                           values=dens_gas, bins=bins,\n                                           xrange=xrange, yrange=yrange,\n                                           zrange=zrange, cut=cut)\n\n        # Star formation surface density:\n        mask_sf = (time - time_stars &lt; 10)\n        xbins, dx = np.linspace(np.min(xrange), np.max(xrange), sfb,\n                                retstep=True)\n        ybins, dy = np.linspace(np.min(yrange), np.max(yrange), sfb,\n                                retstep=True)\n        H = np.histogram2d(pos_stars[:, 0][mask_sf], pos_stars[:, 1][mask_sf],\n                           bins=[xbins, ybins], weights=mass_stars[mask_sf])[0]\n        with np.errstate(divide='ignore'):\n            H = np.log10(H.T/(dx * dy) / (10 * 1e6))\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im_gas = ax.imshow(np.log10(interpDens), origin='lower',\n                           extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                           vmin=self.vmin, vmax=self.vmax, cmap='Greys')\n        ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none',\n                      'alpha': 0.5, 'boxstyle': 'round'})\n        ax.set_aspect('equal')\n        ax.set_xlabel('$x$ [kpc]')\n        ax.set_ylabel('$y$ [kpc]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im_gas, cax=cax, label=r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                     + r' $[\\mathrm{g} \\ \\mathrm{cm}^{-2}])$')\n\n        im_sf = ax.imshow(H, origin='lower', cmap='winter',\n                          extent=(xrange[0], xrange[1], yrange[0], yrange[1]))\n        cax = ax.inset_axes([0.02, 0.94, 0.7, 0.04])\n        cb = fig.colorbar(im_sf, cax=cax, orientation='horizontal',\n                          location='bottom')\n        cb.set_label(label=r'$\\log_{10}(\\Sigma_\\mathrm{SFR}$'\n                     + r' $[\\mathrm{M}_\\odot$ yr$^{-1}$'\n                     + f'{self.ulengthselect}' + '$^{-2}$' + '])', size=12)\n        cb.ax.tick_params(labelsize=12)\n\n        # Save:\n        print('  * Figure generated successfully')\n        funcname = 'sf'\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def stellar_age(self, axis='z', rotate=0, bins=100, age=100,\n                    interpolation='kdtree', bhfocus=False, xrange=None,\n                    yrange=None, zrange=None, box=None, cut=None):\n        '''\n        Description: TODO\n        '''\n        # Read the data:\n        print('  * Reading data of snapshot')\n        h, iu = read_hdf5(file=self.file)\n        boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n        time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n        pos_gas = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n        dens_gas = h['PartType0']['Density'] * iu['udens']\n        pos_stars = (h['PartType4']['Coordinates'] * iu['ulength']\n                     / self.ulength)\n        time_stars = (h['PartType4']['StellarFormationTime'] * iu['utime']\n                      / const['Myr'])\n\n        print('  * Generating a map highlighting the stellar age of newly' +\n              ' formed star particles')\n\n        # Centre the data on the black hole:\n        if bhfocus:\n            bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n                  / self.ulength)\n            pos_gas -= bh\n            pos_stars -= bh\n\n        # Coordinate ranges:\n        xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                                 xrange=xrange, yrange=yrange,\n                                                 zrange=zrange,\n                                                 bhfocus=bhfocus)\n\n        # Rotation of particle positions:\n        pos_gas = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                   pos=pos_gas, bhfocus=bhfocus)\n        pos_stars = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                     pos=pos_stars, bhfocus=bhfocus)\n\n        # Interpolation:\n        if interpolation == 'kdtree':\n            interpDens = interpolate_to_2d_kdtree(pos=pos_gas,\n                                                  unit=self.ulength,\n                                                  values=dens_gas, bins=bins,\n                                                  xrange=xrange, yrange=yrange,\n                                                  zrange=zrange, cut=cut)\n        else:\n            interpDens = interpolate_to_2d(pos=pos_gas, unit=self.ulength,\n                                           values=dens_gas, bins=bins,\n                                           xrange=xrange, yrange=yrange,\n                                           zrange=zrange, cut=cut)\n\n        # Stars:\n        mask = ((pos_stars[:, 0] &gt; xrange[0]) * (pos_stars[:, 0] &lt; xrange[1])\n                * (pos_stars[:, 1] &gt; yrange[0]) * (pos_stars[:, 1] &lt; yrange[1])\n                * (pos_stars[:, 2] &gt; zrange[0]) * (pos_stars[:, 2] &lt; zrange[1])\n                * (np.abs(time - time_stars) &lt; age))\n\n        # Plot:\n        fig, ax = plt.subplots(figsize=(8, 6.4))\n        fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                            wspace=0, hspace=0)\n\n        im_gas = ax.imshow(np.log10(interpDens), origin='lower', cmap='Greys',\n                           extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                           vmin=self.vmin, vmax=self.vmax)\n        ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n                ha='right', va='bottom', transform=ax.transAxes,\n                bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                      'boxstyle': 'round'})\n        ax.set_aspect('equal')\n        ax.set_xlabel('$x$ [kpc]')\n        ax.set_ylabel('$y$ [kpc]')\n        ax.set_xlim(self.xlim)\n        ax.set_ylim(self.ylim)\n\n        div = make_axes_locatable(ax)\n        cax = div.append_axes('right', size='5%', pad=0)\n        fig.colorbar(im_gas, cax=cax, label=r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                     + r' $[\\mathrm{g} \\ \\mathrm{cm}^{-2}])$')\n\n        time_diff = np.abs(time - time_stars[mask])\n        im_sa = ax.scatter(pos_stars[:, 0][mask], pos_stars[:, 1][mask],\n                           c=time_diff, s=10, marker='.', cmap='viridis',\n                           vmin=0, vmax=np.min([age, np.max(time_diff)]))\n        cax = ax.inset_axes([0.02, 0.94, 0.7, 0.04])\n        cb = fig.colorbar(im_sa, cax=cax, orientation='horizontal',\n                          location='bottom')\n        cb.set_label(label='Stellar age [Myr]', size=12)\n        cb.ax.tick_params(labelsize=12)\n\n        # Save:\n        print('  * Figure generated successfully')\n        funcname = 'sa'\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def black_hole_evolution(self, vcr):\n        '''\n        Description: TODO\n        '''\n        # Snapshot range:\n        file_list = os.listdir()\n        snap_list = [i for i in file_list if 'snap_' in i]\n        snap_list = [i for i in snap_list if 'sink_' not in i]\n        snum_list = [int(i[5:-5]) for i in snap_list]\n        n = np.min(snum_list)\n        N = int(self.file[len(self.file)-8:-5])\n\n        # Obtain the black hole data:\n        BHData = get_black_hole_data(output_dir=os.getcwd(), n=n, N=N,\n                                     vcr=vcr)\n\n        # Collection of plots:\n        ls = '-'\n        lw = 2\n        c = 'tab:blue'\n        fs = 14\n\n        fig, ax = plt.subplots(2, 5, figsize=(14, 5.5), sharex=True,\n                               layout='constrained')\n\n        # Sink mass:\n        ax[0, 0].plot(BHData['Time'], np.log10(BHData['MassSink']),\n                      ls=ls, lw=lw, c=c)\n        ax[0, 0].set_title(r'$\\log_{10}(M_\\mathrm{Sink}$' +\n                           r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n        ax[0, 0].set_xlim(0, np.max(BHData['Time']))\n        ax[0, 0].grid()\n\n        # BH growth:\n        ax[0, 1].plot(BHData['Time'], np.log10(BHData['MassBH']),\n                      ls=ls, lw=lw, c=c)\n        ax[0, 1].set_title(r'$\\log_{10}(M_\\mathrm{BH} \\ [\\mathrm{M}_\\odot])$',\n                           fontsize=fs)\n        ax[0, 1].grid()\n\n        # Gas reservoir:\n        GasReserv = np.array(BHData['MassReserv'])\n        GasReserv[GasReserv &lt;= 0] = 1e-99\n        ax[0, 2].plot(BHData['Time'], np.log10(GasReserv), ls=ls, lw=lw, c=c)\n        ax[0, 2].set_title(r'$\\log_{10}(M_\\mathrm{Reserv}$' +\n                           r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n        ax[0, 2].set_ylim(-9, 5)\n        ax[0, 2].grid()\n\n        # Gas accretion disk:\n        AccDisk = np.array(BHData['MassDisk'])\n        AccDisk[AccDisk &lt;= 0] = 1e-99\n        ax[0, 3].plot(BHData['Time'], np.log10(AccDisk), ls=ls, lw=lw, c=c)\n        ax[0, 3].set_title(r'$\\log_{10}(M_\\mathrm{Disk}$' +\n                           r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n        ax[0, 3].set_ylim(-9, 5)\n        ax[0, 3].grid()\n\n        # Relative error:\n        mass_diff = ((np.array(BHData['MassSink'])\n                      - np.array(BHData['MassReserv'])\n                      - np.array(BHData['MassDisk'])\n                      - np.array(BHData['MassBH']))\n                     / np.array(BHData['MassSink']))\n        ax[0, 4].plot(BHData['Time'], mass_diff, lw=lw, c=c)\n        ax[0, 4].set_title('Relative Error', fontsize=fs)\n        ax[0, 4].set_yscale('linear')\n        ax[0, 4].grid()\n\n        # Sink accretion rate:\n        FracEddSink = np.array(BHData['MdotSink'])/np.array(BHData['MdotEdd'])\n        FracEddSink[FracEddSink &lt;= 0] = 1e-99\n        ax[1, 0].stairs(np.log10(FracEddSink), BHData['Time'], baseline=-99,\n                        lw=lw, color=c, alpha=0.8, fill=True, rasterized=True)\n        ax[1, 0].axhline(0, c='k', ls=':', lw=1, zorder=9)\n        ax[1, 0].axhline(np.log10(0.02), c='k', ls='--', lw=1, zorder=9)\n        ax[1, 0].set_xlabel('Time [Myr]')\n        ax[1, 0].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{Sink}/$' +\n                           r'$\\dot{M}_\\mathrm{Edd})$', fontsize=fs)\n        ax[1, 0].set_ylim(-9, 1)\n        ax[1, 0].grid()\n\n        MdotSink = np.array(BHData['MdotSink'])\n        MdotSink[MdotSink &lt;= 0] = 1e-99\n        ax[1, 1].stairs(np.log10(MdotSink), BHData['Time'], baseline=-99,\n                        lw=lw, color=c, alpha=0.8, fill=True, rasterized=True)\n        ax[1, 1].set_xlabel('Time [Myr]')\n        ax[1, 1].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{Sink}$' +\n                           r'$ [\\mathrm{M}_\\odot \\ \\mathrm{yr}^{-1}])$',\n                           fontsize=fs)\n        ax[1, 1].set_ylim(-9, -3)\n        ax[1, 1].grid()\n\n        # BH Accretion rate:\n        FracEddBH = np.array(BHData['MdotBH']) / np.array(BHData['MdotEdd'])\n        FracEddBH[FracEddBH &lt;= 0] = 1e-99\n        ax[1, 2].plot(BHData['TimeMid'], np.log10(FracEddBH), lw=lw, c=c,\n                      zorder=10)\n        ax[1, 2].axhline(0, c='k', ls=':', lw=1, zorder=9)\n        ax[1, 2].axhline(np.log10(0.02), c='k', ls='--', lw=1, zorder=9)\n        ax[1, 2].set_xlabel('Time [Myr]')\n        ax[1, 2].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{BH}/$' +\n                           r'$\\dot{M}_\\mathrm{Edd})$', fontsize=fs)\n        ax[1, 2].set_ylim(-9, 1)\n        ax[1, 2].grid()\n\n        MdotBH = np.array(BHData['MdotBH'])\n        MdotBH[MdotBH &lt;= 0] = 1e-99\n        ax[1, 3].plot(BHData['TimeMid'], np.log10(MdotBH), lw=2, c=c,\n                      zorder=10)\n        ax[1, 3].set_xlabel('Time [Myr]')\n        ax[1, 3].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{BH}$' +\n                           r' [M$_\\odot$ yr$^{-1}$])', fontsize=fs)\n        ax[1, 3].set_ylim(-9, -3)\n        ax[1, 3].grid()\n\n        # Circularisation radius:\n        if len(BHData['CircRadius']) &gt; 0:\n            ax[1, 4].plot(BHData['Time'], BHData['CircRadius'], lw=lw, c=c)\n            ax[1, 4].set_xlabel('Time [Myr]')\n            ax[1, 4].set_title(r'$R_\\mathrm{circ}$ [left: pc, right: ' +\n                               r'$r_\\mathrm{s}$]', fontsize=fs)\n            ax[1, 4].set_yscale('linear')\n            ax[1, 4].grid()\n\n            ax2 = ax[1, 4].twinx()\n            rs = (2 * const['G'] * BHData['MassBH'][0] * const['Msol'] /\n                  np.power(const['c'], 2))\n            Rcirc = np.array(BHData['CircRadius']) * const['pc'] / rs\n            ax2.plot(BHData['Time'], Rcirc, lw=lw, c=c)\n            ax2.set_yscale('linear')\n        else:\n            ax[1, 4].set_visible(False)\n\n        # Save:\n        print('  * Figure generated successfully')\n        funcname = 'bhevol'\n        self.save(fig=fig, funcname=funcname)\n\n        # Display figure:\n        if self.show is not True:\n            print('  * Interactive display of figure is NOT allowed')\n            plt.close()\n        else:\n            print('  * Interactive display of figure is now running')\n            plt.show()\n\n        return None\n\n    ##########################################################################\n    ##########################################################################\n    def ffmpeg(self, framedir, skip):\n        '''\n        Description: TODO\n        '''\n\n        if os.path.isdir(f'./vframes/{framedir}'):\n            fnr = 0\n            if skip:\n                fnr += 1\n            frame = '000'[:3-len(str(fnr))] + str(fnr)\n            print(f'  * Searching for {framedir} frames')\n            while os.path.isfile(f'./vframes/{framedir}/' +\n                                 f'{framedir}_{frame}.png'):\n                fnr += 1\n                frame = '000'[:3-len(str(fnr))] + str(fnr)\n            print(f'  * Found {fnr} frames!')\n\n        start = 0\n        if skip:\n            start += 1\n        file_split = self.file.split('.')\n        vframes = int(file_split[0][-3:])\n        if not skip:\n            vframes += 1\n        if vframes &gt; fnr:\n            print('  * Trying to generate a movie up to a given snapshot' +\n                  ' without the neccessary frames needed to do so,' +\n                  ' therefore, exiting the ffmpeg function')\n            return None\n        fps = 15\n        res_width = 1920\n        res_height = 1080\n\n        f = os.system(f'ffmpeg -r {fps} -f image2 -y' +\n                      f' -s {res_width}x{res_height}' +\n                      f' -start_number {start}' +\n                      f' -i {os.getcwd()}/vframes/{framedir}/' +\n                      f'{framedir}_%03d.png' +\n                      f' -vframes {vframes}' +\n                      ' -vcodec libx264' +\n                      ' -vf \"pad=ceil(iw/2)*2:ceil(ih/2)*2:color=white\"' +\n                      ' -crf 25' +\n                      ' -pix_fmt yuv420p' +\n                      f' {os.getcwd()}/{framedir}.mp4' +\n                      ' &gt; ffmpeg.out 2&gt; ffmpeg.err')\n        if f == 0:\n            print('  * Film successfully generated!')\n        else:\n            print('  * Error: Something went wrong, please check the ffmpeg' +\n                  ' output/error file')\n\n        return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.black_hole_evolution","title":"<code>black_hole_evolution(vcr)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def black_hole_evolution(self, vcr):\n    '''\n    Description: TODO\n    '''\n    # Snapshot range:\n    file_list = os.listdir()\n    snap_list = [i for i in file_list if 'snap_' in i]\n    snap_list = [i for i in snap_list if 'sink_' not in i]\n    snum_list = [int(i[5:-5]) for i in snap_list]\n    n = np.min(snum_list)\n    N = int(self.file[len(self.file)-8:-5])\n\n    # Obtain the black hole data:\n    BHData = get_black_hole_data(output_dir=os.getcwd(), n=n, N=N,\n                                 vcr=vcr)\n\n    # Collection of plots:\n    ls = '-'\n    lw = 2\n    c = 'tab:blue'\n    fs = 14\n\n    fig, ax = plt.subplots(2, 5, figsize=(14, 5.5), sharex=True,\n                           layout='constrained')\n\n    # Sink mass:\n    ax[0, 0].plot(BHData['Time'], np.log10(BHData['MassSink']),\n                  ls=ls, lw=lw, c=c)\n    ax[0, 0].set_title(r'$\\log_{10}(M_\\mathrm{Sink}$' +\n                       r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n    ax[0, 0].set_xlim(0, np.max(BHData['Time']))\n    ax[0, 0].grid()\n\n    # BH growth:\n    ax[0, 1].plot(BHData['Time'], np.log10(BHData['MassBH']),\n                  ls=ls, lw=lw, c=c)\n    ax[0, 1].set_title(r'$\\log_{10}(M_\\mathrm{BH} \\ [\\mathrm{M}_\\odot])$',\n                       fontsize=fs)\n    ax[0, 1].grid()\n\n    # Gas reservoir:\n    GasReserv = np.array(BHData['MassReserv'])\n    GasReserv[GasReserv &lt;= 0] = 1e-99\n    ax[0, 2].plot(BHData['Time'], np.log10(GasReserv), ls=ls, lw=lw, c=c)\n    ax[0, 2].set_title(r'$\\log_{10}(M_\\mathrm{Reserv}$' +\n                       r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n    ax[0, 2].set_ylim(-9, 5)\n    ax[0, 2].grid()\n\n    # Gas accretion disk:\n    AccDisk = np.array(BHData['MassDisk'])\n    AccDisk[AccDisk &lt;= 0] = 1e-99\n    ax[0, 3].plot(BHData['Time'], np.log10(AccDisk), ls=ls, lw=lw, c=c)\n    ax[0, 3].set_title(r'$\\log_{10}(M_\\mathrm{Disk}$' +\n                       r' $[\\mathrm{M}_\\odot])$', fontsize=fs)\n    ax[0, 3].set_ylim(-9, 5)\n    ax[0, 3].grid()\n\n    # Relative error:\n    mass_diff = ((np.array(BHData['MassSink'])\n                  - np.array(BHData['MassReserv'])\n                  - np.array(BHData['MassDisk'])\n                  - np.array(BHData['MassBH']))\n                 / np.array(BHData['MassSink']))\n    ax[0, 4].plot(BHData['Time'], mass_diff, lw=lw, c=c)\n    ax[0, 4].set_title('Relative Error', fontsize=fs)\n    ax[0, 4].set_yscale('linear')\n    ax[0, 4].grid()\n\n    # Sink accretion rate:\n    FracEddSink = np.array(BHData['MdotSink'])/np.array(BHData['MdotEdd'])\n    FracEddSink[FracEddSink &lt;= 0] = 1e-99\n    ax[1, 0].stairs(np.log10(FracEddSink), BHData['Time'], baseline=-99,\n                    lw=lw, color=c, alpha=0.8, fill=True, rasterized=True)\n    ax[1, 0].axhline(0, c='k', ls=':', lw=1, zorder=9)\n    ax[1, 0].axhline(np.log10(0.02), c='k', ls='--', lw=1, zorder=9)\n    ax[1, 0].set_xlabel('Time [Myr]')\n    ax[1, 0].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{Sink}/$' +\n                       r'$\\dot{M}_\\mathrm{Edd})$', fontsize=fs)\n    ax[1, 0].set_ylim(-9, 1)\n    ax[1, 0].grid()\n\n    MdotSink = np.array(BHData['MdotSink'])\n    MdotSink[MdotSink &lt;= 0] = 1e-99\n    ax[1, 1].stairs(np.log10(MdotSink), BHData['Time'], baseline=-99,\n                    lw=lw, color=c, alpha=0.8, fill=True, rasterized=True)\n    ax[1, 1].set_xlabel('Time [Myr]')\n    ax[1, 1].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{Sink}$' +\n                       r'$ [\\mathrm{M}_\\odot \\ \\mathrm{yr}^{-1}])$',\n                       fontsize=fs)\n    ax[1, 1].set_ylim(-9, -3)\n    ax[1, 1].grid()\n\n    # BH Accretion rate:\n    FracEddBH = np.array(BHData['MdotBH']) / np.array(BHData['MdotEdd'])\n    FracEddBH[FracEddBH &lt;= 0] = 1e-99\n    ax[1, 2].plot(BHData['TimeMid'], np.log10(FracEddBH), lw=lw, c=c,\n                  zorder=10)\n    ax[1, 2].axhline(0, c='k', ls=':', lw=1, zorder=9)\n    ax[1, 2].axhline(np.log10(0.02), c='k', ls='--', lw=1, zorder=9)\n    ax[1, 2].set_xlabel('Time [Myr]')\n    ax[1, 2].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{BH}/$' +\n                       r'$\\dot{M}_\\mathrm{Edd})$', fontsize=fs)\n    ax[1, 2].set_ylim(-9, 1)\n    ax[1, 2].grid()\n\n    MdotBH = np.array(BHData['MdotBH'])\n    MdotBH[MdotBH &lt;= 0] = 1e-99\n    ax[1, 3].plot(BHData['TimeMid'], np.log10(MdotBH), lw=2, c=c,\n                  zorder=10)\n    ax[1, 3].set_xlabel('Time [Myr]')\n    ax[1, 3].set_title(r'$\\log_{10}(\\dot{M}_\\mathrm{BH}$' +\n                       r' [M$_\\odot$ yr$^{-1}$])', fontsize=fs)\n    ax[1, 3].set_ylim(-9, -3)\n    ax[1, 3].grid()\n\n    # Circularisation radius:\n    if len(BHData['CircRadius']) &gt; 0:\n        ax[1, 4].plot(BHData['Time'], BHData['CircRadius'], lw=lw, c=c)\n        ax[1, 4].set_xlabel('Time [Myr]')\n        ax[1, 4].set_title(r'$R_\\mathrm{circ}$ [left: pc, right: ' +\n                           r'$r_\\mathrm{s}$]', fontsize=fs)\n        ax[1, 4].set_yscale('linear')\n        ax[1, 4].grid()\n\n        ax2 = ax[1, 4].twinx()\n        rs = (2 * const['G'] * BHData['MassBH'][0] * const['Msol'] /\n              np.power(const['c'], 2))\n        Rcirc = np.array(BHData['CircRadius']) * const['pc'] / rs\n        ax2.plot(BHData['Time'], Rcirc, lw=lw, c=c)\n        ax2.set_yscale('linear')\n    else:\n        ax[1, 4].set_visible(False)\n\n    # Save:\n    print('  * Figure generated successfully')\n    funcname = 'bhevol'\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.darkmatter","title":"<code>darkmatter(axis='z', rotate=0, bins=100, bhfocus=False, xrange=None, yrange=None, zrange=None, box=None)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def darkmatter(self, axis='z', rotate=0, bins=100, bhfocus=False,\n               xrange=None, yrange=None, zrange=None, box=None):\n    '''\n    Description: TODO\n    '''\n    # Read the data:\n    print('  * Reading data of snapshot')\n    h, iu = read_hdf5(file=self.file)\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n\n    # DM component:\n    pos = h['PartType1']['Coordinates'] * iu['ulength'] / const['kpc']\n    if 'Masses' in h['PartType1']:\n        mass = h['PartType1']['Masses'] * iu['umass'] / const['Msol']\n    else:\n        mass = np.full(len(pos), h['Header'].attrs['MassTable'][1]\n                       * iu['umass'] / const['Msol'])\n\n    print('  * Generating a dark matter surface density map')\n\n    # Centre the data on the black hole:\n    if bhfocus:\n        bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n              / self.ulength)\n        pos -= bh\n\n    # Coordinate ranges:\n    xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                             xrange=xrange, yrange=yrange,\n                                             zrange=zrange,\n                                             bhfocus=bhfocus)\n\n    # Bins in x and y:\n    xbins, dx = np.linspace(xrange[0], xrange[1], bins, retstep=True)\n    ybins, dy = np.linspace(yrange[0], yrange[1], bins, retstep=True)\n\n    # Remove particles outside the zrange:\n    mask = (pos[:, 2] &gt; np.min(zrange)) * (pos[:, 2] &lt; np.max(zrange))\n    pos, mass = pos[mask], mass[mask]\n\n    # Rotation of particle positions:\n    pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                           pos=pos, bhfocus=bhfocus)\n\n    # Histogram 2D:\n    H, xedges, yedges = np.histogram2d(pos[:, 0], pos[:, 1],\n                                       bins=(xbins, ybins), weights=mass)\n    with np.errstate(divide='ignore'):\n        H = np.log10(H.T / (dx * dy))\n\n    # Plot:\n    fig, ax = plt.subplots(figsize=(8, 4), layout='constrained')\n    im = ax.imshow(H, origin='lower',\n                   extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],\n                   vmin=self.vmin, vmax=self.vmax, cmap='magma')\n    ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n            ha='right', va='bottom', transform=ax.transAxes,\n            bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                  'boxstyle': 'round'})\n    bone = mpl.colormaps['magma']\n    ax.set_facecolor(bone(0))\n    ax.set_aspect('equal')\n    ax.set_xlabel('$x$ [kpc]')\n    ax.set_ylabel('$y$ [kpc]')\n    ax.set_xlim(self.xlim)\n    ax.set_ylim(self.ylim)\n    div = make_axes_locatable(ax)\n    cax = div.append_axes('right', size='5%', pad=0)\n    fig.colorbar(im, cax=cax, label=r'$\\log_{10}$($\\Sigma_\\star$'\n                 + r' [M$_\\odot$ kpc$^{-2}$])')\n\n    # Save:\n    print('  * Figure generated successfully')\n    funcname = 'dm'\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.density","title":"<code>density(axis='z', rotate=0, quantity='mass', bins=100, interpolation='kdtree', bhfocus=False, xrange=None, yrange=None, zrange=None, box=None, cut=None)</code>","text":"Function to generate a column density map of the gas <p>surface density, with the possibility to also show the column density of various chemical species, such as HI, HII, and H2. This is achieved by first interpolating the selected gas quantity onto a grid, and later doing a sum along the line-of-sight.</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def density(self, axis='z', rotate=0, quantity='mass', bins=100,\n            interpolation='kdtree', bhfocus=False, xrange=None,\n            yrange=None, zrange=None, box=None, cut=None):\n    '''\n    Description: Function to generate a column density map of the gas\n                 surface density, with the possibility to also show the\n                 column density of various chemical species, such as HI,\n                 HII, and H2. This is achieved by first interpolating the\n                 selected gas quantity onto a grid, and later doing a sum\n                 along the line-of-sight.\n    '''\n    # Read the data:\n    print(f'  * Reading data of {self.file}')\n    h, iu = read_hdf5(file=self.file)\n    pos = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n    dens = h['PartType0']['Density'] * iu['udens']\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n\n    print('  * Generating a gas surface density map')\n\n    # Centre the data on the black hole:\n    if bhfocus:\n        bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n              / self.ulength)\n        pos -= bh\n\n    # Coordinate ranges:\n    xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                             xrange=xrange, yrange=yrange,\n                                             zrange=zrange,\n                                             bhfocus=bhfocus)\n\n    # Selection of gas quantity:\n    if (quantity != 'mass'):\n        num = number_density(h, iu)\n        dens = num[quantity]\n\n    # Rotation of particle positions:\n    pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                           pos=pos, bhfocus=bhfocus)\n\n    # Interpolation:\n    if interpolation == 'kdtree':\n        interpDens = interpolate_to_2d_kdtree(pos=pos, unit=self.ulength,\n                                              values=dens, bins=bins,\n                                              xrange=xrange, yrange=yrange,\n                                              zrange=zrange, cut=cut)\n    else:\n        interpDens = interpolate_to_2d(pos=pos, unit=self.ulength,\n                                       values=dens, bins=bins,\n                                       xrange=xrange, yrange=yrange,\n                                       zrange=zrange, cut=cut)\n\n    # Plot:\n    fig, ax = plt.subplots(figsize=(8, 6.4))\n    fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                        wspace=0, hspace=0)\n\n    im = ax.imshow(np.log10(interpDens), vmin=self.vmin, vmax=self.vmax,\n                   extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                   origin='lower', cmap=configv.cmap['gas'])\n    if bhfocus:\n        ax.scatter(0, 0, s=40, c='k')\n    ax.text(0.95, 0.05, f'{time:.2f} Myr', color='k',\n            ha='right', va='bottom', transform=ax.transAxes,\n            bbox={'facecolor': 'white', 'edgecolor': 'none',\n                  'boxstyle': 'round', 'alpha': 0.5})\n    ax.set_aspect('equal')\n    ax.set_xlabel(f'$x$ [{self.ulengthselect}]')\n    ax.set_ylabel(f'$y$ [{self.ulengthselect}]')\n    ax.set_xlim(self.xlim)\n    ax.set_ylim(self.ylim)\n\n    # Colorbar:\n    if not cut:\n        dim = 2\n    else:\n        dim = 3\n    cbar_label = {\n        'HII': (r'$\\log_{10}(\\Sigma_{\\mathrm{HII}}$'\n                r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'H2': (r'$\\log_{10}(\\Sigma_{\\mathrm{H}_2}$'\n               r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'HI': (r'$\\log_{10}(\\Sigma_{\\mathrm{HI}}$'\n               r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'CO': (r'$\\log_{10}(\\Sigma_{\\mathrm{CO}}$'\n               r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'He': (r'$\\log_{10}(\\Sigma_{\\mathrm{He}}$'\n               r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'e': (r'$\\log_{10}(\\Sigma_{e^{-}}$'\n              r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'n': (r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n              r' $[\\mathrm{cm}^{-%d}])$' % dim),\n        'mass': (r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                 r' $[\\mathrm{g} \\ \\mathrm{cm}^{-%d}])$' % dim)\n    }\n\n    div = make_axes_locatable(ax)\n    cax = div.append_axes('right', size='5%', pad=0)\n    fig.colorbar(im, cax=cax, label=cbar_label[quantity])\n\n    # Save:\n    print('  * Figure generated successfully')\n    funcname = 'dens'\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.do_rotation","title":"<code>do_rotation(boxsize, axis, rotate, pos, bhfocus)</code>","text":"<p>Description: Function to rotate the position of particles.</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def do_rotation(self, boxsize, axis, rotate, pos, bhfocus):\n    '''\n    Description: Function to rotate the position of particles.\n    '''\n    # If applicable, rotate the position of particles:\n    if rotate != 0:\n        rotation = Rotation.from_euler(axis, rotate, degrees=True)\n        if bhfocus:\n            pos = rotation.apply(pos)\n        else:\n            pos = rotation.apply(pos - boxsize/2)\n            pos += boxsize/2\n\n    return pos\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.ffmpeg","title":"<code>ffmpeg(framedir, skip)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def ffmpeg(self, framedir, skip):\n    '''\n    Description: TODO\n    '''\n\n    if os.path.isdir(f'./vframes/{framedir}'):\n        fnr = 0\n        if skip:\n            fnr += 1\n        frame = '000'[:3-len(str(fnr))] + str(fnr)\n        print(f'  * Searching for {framedir} frames')\n        while os.path.isfile(f'./vframes/{framedir}/' +\n                             f'{framedir}_{frame}.png'):\n            fnr += 1\n            frame = '000'[:3-len(str(fnr))] + str(fnr)\n        print(f'  * Found {fnr} frames!')\n\n    start = 0\n    if skip:\n        start += 1\n    file_split = self.file.split('.')\n    vframes = int(file_split[0][-3:])\n    if not skip:\n        vframes += 1\n    if vframes &gt; fnr:\n        print('  * Trying to generate a movie up to a given snapshot' +\n              ' without the neccessary frames needed to do so,' +\n              ' therefore, exiting the ffmpeg function')\n        return None\n    fps = 15\n    res_width = 1920\n    res_height = 1080\n\n    f = os.system(f'ffmpeg -r {fps} -f image2 -y' +\n                  f' -s {res_width}x{res_height}' +\n                  f' -start_number {start}' +\n                  f' -i {os.getcwd()}/vframes/{framedir}/' +\n                  f'{framedir}_%03d.png' +\n                  f' -vframes {vframes}' +\n                  ' -vcodec libx264' +\n                  ' -vf \"pad=ceil(iw/2)*2:ceil(ih/2)*2:color=white\"' +\n                  ' -crf 25' +\n                  ' -pix_fmt yuv420p' +\n                  f' {os.getcwd()}/{framedir}.mp4' +\n                  ' &gt; ffmpeg.out 2&gt; ffmpeg.err')\n    if f == 0:\n        print('  * Film successfully generated!')\n    else:\n        print('  * Error: Something went wrong, please check the ffmpeg' +\n              ' output/error file')\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.get_ranges","title":"<code>get_ranges(boxsize, box, xrange, yrange, zrange, bhfocus)</code>","text":"<p>Description: Function to get x, y, and z ranges.</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def get_ranges(self, boxsize, box, xrange, yrange, zrange, bhfocus):\n    '''\n    Description: Function to get x, y, and z ranges.\n    '''\n    # Determine the coordinate ranges:\n    if not box:\n        if not xrange:\n            if bhfocus:\n                xrange = (-boxsize/2, boxsize/2)\n            else:\n                xrange = (0, boxsize)\n        if not yrange:\n            if bhfocus:\n                yrange = (-boxsize/2, boxsize/2)\n            else:\n                yrange = (0, boxsize)\n        if not zrange:\n            if bhfocus:\n                zrange = (-boxsize/2, boxsize/2)\n            else:\n                zrange = (0, boxsize)\n    else:\n        xrange = (box[0], box[1])\n        yrange = (box[0], box[1])\n        zrange = (box[0], box[1])\n\n    return xrange, yrange, zrange\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.info","title":"<code>info()</code>","text":"Function to provide some general information about the <p>given snapshot, such as the physical time, size of the simulation domain, number of particles, etc.</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def info(self):\n    '''\n    Description: Function to provide some general information about the\n                 given snapshot, such as the physical time, size of the\n                 simulation domain, number of particles, etc.\n    '''\n    # Read the data:\n    h, iu = read_hdf5(file=self.file)\n\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n    numpart = h['Header'].attrs['NumPart_ThisFile']\n\n    print('  * Snapshot information')\n    print(f'  | Time    : {round(time, 2)} Myr')\n    print(f'  | BoxSize : {round(boxsize, 2)} kpc')\n    print('  |')\n    print('  | Number of particles')\n    print(f'  | PartType0 (gas)      : {numpart[0]}')\n    print(f'  | PartType1 (halo)     : {numpart[1]}')\n    print(f'  | PartType2 (disk)     : {numpart[2]}')\n    print(f'  | PartType3 (bulge)    : {numpart[3]}')\n    print(f'  | PartType4 (stars)    : {numpart[4]}')\n    print(f'  | PartType5 (bndry)    : {numpart[5]}')\n    print(f'  | Total Particle Count : {np.sum(numpart)}')\n    print('  | ')\n\n    mt = h['Header'].attrs['MassTable']\n    print('  | Table of Particle Masses [i.u.]')\n    print(f'  | {mt[0]}, {mt[1]}, {mt[2]}, {mt[3]}, {mt[4]}, {mt[5]}')\n\n    if numpart[5] == 1:\n        print('  |')\n        print('  * A central BH detected')\n        Pbh = h['PartType5']['Coordinates'][0]\n        print(f'  | Coordinates [i.u.] : ({Pbh[0]}, {Pbh[1]}, {Pbh[2]})')\n        Vbh = h['PartType5']['Velocities'][0]\n        print(f'  | Velocities [i.u.]  : ({Vbh[0]}, {Vbh[1]}, {Vbh[2]})')\n        Mbh = h['PartType5']['Masses'][0] * iu['umass'] / const['Msol']\n        print(f'  | Mass [i.u.]        : {Mbh}')\n        IDbh = h['PartType5']['ParticleIDs'][0]\n        print(f'  | Particle ID        : {IDbh}')\n\n    print('  |')\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.resolution","title":"<code>resolution(bins=100, levels=5, smooth=0)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def resolution(self, bins=100, levels=5, smooth=0):\n    '''\n    Description: TODO\n    '''\n    # Read the data:\n    h, iu = read_hdf5(file=self.file)\n    mass = h['PartType0']['Masses'] * iu['umass']\n    dens = h['PartType0']['Density'] * iu['udens']\n    radius = ((3*mass) / (4*np.pi*dens))**(1/3)\n\n    # 2D Histograms:\n    H0, xedges0, yedges0 = np.histogram2d(np.log10(dens),\n                                          np.log10(radius / const['pc']),\n                                          bins=bins)\n    H1, xedges1, yedges1 = np.histogram2d(np.log10(dens),\n                                          np.log10(mass / const['Msol']),\n                                          bins=bins)\n\n    # Gaussian filter:\n    if smooth &gt; 0:\n        H0 = gaussian_filter(H0, sigma=smooth)\n        H1 = gaussian_filter(H1, sigma=smooth)\n\n    # Log scale:\n    with np.errstate(divide='ignore'):\n        H0 = np.log10(H0.T)\n        H1 = np.log10(H1.T)\n\n    # Figure:\n    fig, ax = plt.subplots(2, 1, figsize=(7, 7), sharex=True)\n    fig.subplots_adjust(left=0.15, right=0.85, bottom=0.15, top=0.95,\n                        wspace=0, hspace=0)\n\n    # Density vs Radius:\n    cf = ax[0].contourf(H0, levels=levels, extent=(xedges0[0], xedges0[-1],\n                        yedges0[0], yedges0[-1]), origin='lower',\n                        cmap=configv.cmap['default'])\n    ax[0].set_ylabel(r'$\\log_{10}(r_\\mathrm{cell} \\ [\\mathrm{pc}])$')\n    ax[0].grid()\n    ax[0].set_xlim(self.xlim)\n\n    cax = ax[0].inset_axes([1, -1, 0.05, 2])\n    fig.colorbar(cf, cax=cax, label=r'$\\log_{10}(N_\\mathrm{cells})$')\n\n    # Density vs Mass:\n    ax[1].contourf(H1, levels=levels, extent=(xedges1[0], xedges1[-1],\n                   yedges1[0], yedges1[-1]), origin='lower',\n                   cmap=configv.cmap['default'])\n    ax[1].set_ylabel(r'$\\log_{10}(M_\\mathrm{cell} \\ [\\mathrm{M}_\\odot])$')\n    ax[1].set_xlabel(r'$\\log_{10}(\\rho_\\mathrm{cell}$' +\n                     r' $[\\mathrm{g} \\ \\mathrm{cm}^{-3}])$')\n    ax[1].grid()\n\n    # Jeans length:\n    ax[0].autoscale(False)\n    xlim = ax[0].get_xlim()\n    xlim = np.array(xlim)\n\n    mu = (1 + 4 * 0.1)\n    jeans10 = np.sqrt((15 * self.kb * 10) / (4 * np.pi * self.G * mu *\n                                             self.mp * 10**(xlim)))\n    jeans100 = np.sqrt((15 * self.kb * 100) / (4 * np.pi * self.G * mu *\n                                               self.mp * 10**(xlim)))\n\n    ax[0].plot(xlim, np.log10(jeans10 / const['pc']), c='k', ls='--',\n               lw=1, alpha=0.8, label=r'$\\Lambda_J$($T=10$ K)')\n    ax[0].plot(xlim, np.log10(jeans100 / const['pc']), c='k', ls='--',\n               lw=1, alpha=0.8, label=r'$\\Lambda_J$($T=100$ K)')\n    labelLines(ax[0].get_lines(), xvals=[-24, -24], ha='center',\n               fontsize=14)\n\n    # Save:\n    print('  * Figure generated successfully')\n    funcname = 'resol'\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.save","title":"<code>save(fig, funcname)</code>","text":"<p>Description: Function to save figures.</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def save(self, fig, funcname):\n    '''\n    Description: Function to save figures.\n    '''\n    # Figure name:\n    filestr = self.file.split('.')\n    figname = f'{funcname}_{filestr[0]}'\n    if self.savename:\n        figname = self.savename + '_' + filestr[0][-3:]\n    figname += f'.{self.saveformat}'\n\n    # Check if Vatpy plot directory already exists:\n    if os.path.isdir(self.savepath):\n        print('  * Path where to save figure found')\n    else:\n        print('  * Path where to save figure NOT found')\n        print('  * Creating a \\'vplot\\' directory')\n        os.mkdir(f'{os.getcwd()}/vplots/')\n\n    # Save figure:\n    fig.savefig(f'{self.savepath}/{figname}')\n    print('  * Figure saved successfully as')\n    print(f'    - name: {figname}')\n    print(f'    - path: {self.savepath}')\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.star_formation","title":"<code>star_formation(axis='z', rotate=0, bins=100, sfb=100, interpolation='kdtree', bhfocus=False, xrange=None, yrange=None, zrange=None, box=None, cut=None)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def star_formation(self, axis='z', rotate=0, bins=100, sfb=100,\n                   interpolation='kdtree', bhfocus=False, xrange=None,\n                   yrange=None, zrange=None, box=None, cut=None):\n    '''\n    Description: TODO\n    '''\n    # Read the data:\n    print('  * Reading data of snapshot')\n    h, iu = read_hdf5(file=self.file)\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n    pos_gas = h['PartType0']['Coordinates'] * iu['ulength'] / const['kpc']\n    dens_gas = h['PartType0']['Density'] * iu['udens']\n    pos_stars = (h['PartType4']['Coordinates'] * iu['ulength']\n                 / const['kpc'])\n    mass_stars = h['PartType4']['Masses'] * iu['umass'] / const['Msol']\n    time_stars = (h['PartType4']['StellarFormationTime'] * iu['utime']\n                  / const['Myr'])\n\n    print('  * Generating a star formation rate surface density map')\n\n    # Centre the data on the black hole:\n    if bhfocus:\n        bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n              / self.ulength)\n        pos_gas -= bh\n        pos_stars -= bh\n\n    # Coordinate ranges:\n    xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                             xrange=xrange, yrange=yrange,\n                                             zrange=zrange,\n                                             bhfocus=bhfocus)\n\n    # Rotation of particle positions:\n    pos_gas = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos_gas, bhfocus=bhfocus)\n    pos_stars = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                 pos=pos_stars, bhfocus=bhfocus)\n\n    # Interpolation:\n    if interpolation == 'kdtree':\n        interpDens = interpolate_to_2d_kdtree(pos=pos_gas,\n                                              unit=self.ulength,\n                                              values=dens_gas, bins=bins,\n                                              xrange=xrange, yrange=yrange,\n                                              zrange=zrange, cut=cut)\n    else:\n        interpDens = interpolate_to_2d(pos=pos_gas, unit=self.ulength,\n                                       values=dens_gas, bins=bins,\n                                       xrange=xrange, yrange=yrange,\n                                       zrange=zrange, cut=cut)\n\n    # Star formation surface density:\n    mask_sf = (time - time_stars &lt; 10)\n    xbins, dx = np.linspace(np.min(xrange), np.max(xrange), sfb,\n                            retstep=True)\n    ybins, dy = np.linspace(np.min(yrange), np.max(yrange), sfb,\n                            retstep=True)\n    H = np.histogram2d(pos_stars[:, 0][mask_sf], pos_stars[:, 1][mask_sf],\n                       bins=[xbins, ybins], weights=mass_stars[mask_sf])[0]\n    with np.errstate(divide='ignore'):\n        H = np.log10(H.T/(dx * dy) / (10 * 1e6))\n\n    # Plot:\n    fig, ax = plt.subplots(figsize=(8, 6.4))\n    fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                        wspace=0, hspace=0)\n\n    im_gas = ax.imshow(np.log10(interpDens), origin='lower',\n                       extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                       vmin=self.vmin, vmax=self.vmax, cmap='Greys')\n    ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n            ha='right', va='bottom', transform=ax.transAxes,\n            bbox={'facecolor': 'white', 'edgecolor': 'none',\n                  'alpha': 0.5, 'boxstyle': 'round'})\n    ax.set_aspect('equal')\n    ax.set_xlabel('$x$ [kpc]')\n    ax.set_ylabel('$y$ [kpc]')\n    ax.set_xlim(self.xlim)\n    ax.set_ylim(self.ylim)\n\n    div = make_axes_locatable(ax)\n    cax = div.append_axes('right', size='5%', pad=0)\n    fig.colorbar(im_gas, cax=cax, label=r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                 + r' $[\\mathrm{g} \\ \\mathrm{cm}^{-2}])$')\n\n    im_sf = ax.imshow(H, origin='lower', cmap='winter',\n                      extent=(xrange[0], xrange[1], yrange[0], yrange[1]))\n    cax = ax.inset_axes([0.02, 0.94, 0.7, 0.04])\n    cb = fig.colorbar(im_sf, cax=cax, orientation='horizontal',\n                      location='bottom')\n    cb.set_label(label=r'$\\log_{10}(\\Sigma_\\mathrm{SFR}$'\n                 + r' $[\\mathrm{M}_\\odot$ yr$^{-1}$'\n                 + f'{self.ulengthselect}' + '$^{-2}$' + '])', size=12)\n    cb.ax.tick_params(labelsize=12)\n\n    # Save:\n    print('  * Figure generated successfully')\n    funcname = 'sf'\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.stellar","title":"<code>stellar(axis='z', rotate=0, bins=100, bhfocus=False, xrange=None, yrange=None, zrange=None, box=None)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def stellar(self, axis='z', rotate=0, bins=100, bhfocus=False,\n            xrange=None, yrange=None, zrange=None, box=None):\n    '''\n    Description: TODO\n    '''\n    # Read the data:\n    print('  * Reading data of snapshot')\n    h, iu = read_hdf5(file=self.file)\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / const['kpc']\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n\n    # Stellar component:\n    pos_disk = h['PartType2']['Coordinates'] * iu['ulength'] / const['kpc']\n    mass_disk = h['PartType2']['Masses'] * iu['umass'] / const['Msol']\n\n    pos = pos_disk\n    mass = mass_disk\n\n    print('  * Generating a stellar surface density map')\n\n    # Centre the data on the black hole:\n    if bhfocus:\n        bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n              / self.ulength)\n        pos -= bh\n\n    # Coordinate ranges:\n    xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                             xrange=xrange, yrange=yrange,\n                                             zrange=zrange,\n                                             bhfocus=bhfocus)\n\n    # Bins in x and y:\n    xbins, dx = np.linspace(xrange[0], xrange[1], bins, retstep=True)\n    ybins, dy = np.linspace(yrange[0], yrange[1], bins, retstep=True)\n\n    # Remove particles outside the zrange:\n    mask = (pos[:, 2] &gt; np.min(zrange)) * (pos[:, 2] &lt; np.max(zrange))\n    pos, mass = pos[mask], mass[mask]\n\n    # Rotation of particle positions:\n    pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                           pos=pos, bhfocus=bhfocus)\n\n    # Histogram 2D:\n    H, xedges, yedges = np.histogram2d(pos[:, 0], pos[:, 1],\n                                       bins=(xbins, ybins), weights=mass)\n    with np.errstate(divide='ignore'):\n        H = np.log10(H.T / (dx * dy))\n\n    # Plot:\n    fig, ax = plt.subplots(figsize=(8, 6.4))\n    fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                        wspace=0, hspace=0)\n\n    im = ax.imshow(H, origin='lower',\n                   extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]],\n                   vmin=self.vmin, vmax=self.vmax, cmap='bone')\n    ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n            ha='right', va='bottom', transform=ax.transAxes,\n            bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                  'boxstyle': 'round'})\n    bone = mpl.colormaps['bone']\n    ax.set_facecolor(bone(0))\n    ax.set_aspect('equal')\n    ax.set_xlabel('$x$ [kpc]')\n    ax.set_ylabel('$y$ [kpc]')\n    ax.set_xlim(self.xlim)\n    ax.set_ylim(self.ylim)\n    div = make_axes_locatable(ax)\n    cax = div.append_axes('right', size='5%', pad=0)\n    fig.colorbar(im, cax=cax, label=r'$\\log_{10}$($\\Sigma_\\star$'\n                 + r' [M$_\\odot$ kpc$^{-2}$])')\n\n    # Save:\n    print('  * Figure generated successfully')\n    funcname = 'stellar'\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.stellar_age","title":"<code>stellar_age(axis='z', rotate=0, bins=100, age=100, interpolation='kdtree', bhfocus=False, xrange=None, yrange=None, zrange=None, box=None, cut=None)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def stellar_age(self, axis='z', rotate=0, bins=100, age=100,\n                interpolation='kdtree', bhfocus=False, xrange=None,\n                yrange=None, zrange=None, box=None, cut=None):\n    '''\n    Description: TODO\n    '''\n    # Read the data:\n    print('  * Reading data of snapshot')\n    h, iu = read_hdf5(file=self.file)\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n    pos_gas = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n    dens_gas = h['PartType0']['Density'] * iu['udens']\n    pos_stars = (h['PartType4']['Coordinates'] * iu['ulength']\n                 / self.ulength)\n    time_stars = (h['PartType4']['StellarFormationTime'] * iu['utime']\n                  / const['Myr'])\n\n    print('  * Generating a map highlighting the stellar age of newly' +\n          ' formed star particles')\n\n    # Centre the data on the black hole:\n    if bhfocus:\n        bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n              / self.ulength)\n        pos_gas -= bh\n        pos_stars -= bh\n\n    # Coordinate ranges:\n    xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                             xrange=xrange, yrange=yrange,\n                                             zrange=zrange,\n                                             bhfocus=bhfocus)\n\n    # Rotation of particle positions:\n    pos_gas = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                               pos=pos_gas, bhfocus=bhfocus)\n    pos_stars = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                                 pos=pos_stars, bhfocus=bhfocus)\n\n    # Interpolation:\n    if interpolation == 'kdtree':\n        interpDens = interpolate_to_2d_kdtree(pos=pos_gas,\n                                              unit=self.ulength,\n                                              values=dens_gas, bins=bins,\n                                              xrange=xrange, yrange=yrange,\n                                              zrange=zrange, cut=cut)\n    else:\n        interpDens = interpolate_to_2d(pos=pos_gas, unit=self.ulength,\n                                       values=dens_gas, bins=bins,\n                                       xrange=xrange, yrange=yrange,\n                                       zrange=zrange, cut=cut)\n\n    # Stars:\n    mask = ((pos_stars[:, 0] &gt; xrange[0]) * (pos_stars[:, 0] &lt; xrange[1])\n            * (pos_stars[:, 1] &gt; yrange[0]) * (pos_stars[:, 1] &lt; yrange[1])\n            * (pos_stars[:, 2] &gt; zrange[0]) * (pos_stars[:, 2] &lt; zrange[1])\n            * (np.abs(time - time_stars) &lt; age))\n\n    # Plot:\n    fig, ax = plt.subplots(figsize=(8, 6.4))\n    fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                        wspace=0, hspace=0)\n\n    im_gas = ax.imshow(np.log10(interpDens), origin='lower', cmap='Greys',\n                       extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                       vmin=self.vmin, vmax=self.vmax)\n    ax.text(0.95, 0.05, f'{round(time, 2)} Myr', color='k',\n            ha='right', va='bottom', transform=ax.transAxes,\n            bbox={'facecolor': 'white', 'edgecolor': 'none', 'alpha': 0.5,\n                  'boxstyle': 'round'})\n    ax.set_aspect('equal')\n    ax.set_xlabel('$x$ [kpc]')\n    ax.set_ylabel('$y$ [kpc]')\n    ax.set_xlim(self.xlim)\n    ax.set_ylim(self.ylim)\n\n    div = make_axes_locatable(ax)\n    cax = div.append_axes('right', size='5%', pad=0)\n    fig.colorbar(im_gas, cax=cax, label=r'$\\log_{10}(\\Sigma_\\mathrm{Gas}$'\n                 + r' $[\\mathrm{g} \\ \\mathrm{cm}^{-2}])$')\n\n    time_diff = np.abs(time - time_stars[mask])\n    im_sa = ax.scatter(pos_stars[:, 0][mask], pos_stars[:, 1][mask],\n                       c=time_diff, s=10, marker='.', cmap='viridis',\n                       vmin=0, vmax=np.min([age, np.max(time_diff)]))\n    cax = ax.inset_axes([0.02, 0.94, 0.7, 0.04])\n    cb = fig.colorbar(im_sa, cax=cax, orientation='horizontal',\n                      location='bottom')\n    cb.set_label(label='Stellar age [Myr]', size=12)\n    cb.ax.tick_params(labelsize=12)\n\n    # Save:\n    print('  * Figure generated successfully')\n    funcname = 'sa'\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"docstrings/#vatpy.terminal_plot.TerminalPlot.temperature","title":"<code>temperature(axis='z', rotate=0, bins=100, interpolation='kdtree', bhfocus=False, xrange=None, yrange=None, zrange=None, box=None, cut=None)</code>","text":"<p>Description: TODO</p> Source code in <code>vatpy/terminal_plot.py</code> <pre><code>def temperature(self, axis='z', rotate=0, bins=100, interpolation='kdtree',\n                bhfocus=False, xrange=None, yrange=None, zrange=None,\n                box=None, cut=None):\n    '''\n    Description: TODO\n    '''\n    # Read the data:\n    print('  * Reading data of snapshot')\n    h, iu = read_hdf5(file=self.file)\n    pos = h['PartType0']['Coordinates'] * iu['ulength'] / self.ulength\n    dens = h['PartType0']['Density'] * iu['udens']\n    time = h['Header'].attrs['Time'] * iu['utime'] / const['Myr']\n    boxsize = h['Header'].attrs['BoxSize'] * iu['ulength'] / self.ulength\n    temp = temperature(h, iu)\n\n    print('  * Generating a gas temperature (density-weighted) map')\n\n    # Centre the data on the black hole:\n    if bhfocus:\n        bh = (h['PartType5']['Coordinates'][0] * iu['ulength']\n              / self.ulength)\n        pos -= bh\n\n    # Coordinate ranges:\n    xrange, yrange, zrange = self.get_ranges(boxsize=boxsize, box=box,\n                                             xrange=xrange, yrange=yrange,\n                                             zrange=zrange,\n                                             bhfocus=bhfocus)\n\n    # Rotation of particle positions:\n    pos = self.do_rotation(boxsize=boxsize, axis=axis, rotate=rotate,\n                           pos=pos, bhfocus=bhfocus)\n\n    # Interpolation:\n    if interpolation == 'kdtree':\n        interpTemp = interpolate_to_2d_kdtree(pos=pos, unit=self.ulength,\n                                              values=temp, bins=bins,\n                                              xrange=xrange, yrange=yrange,\n                                              zrange=zrange, cut=cut,\n                                              weights=dens)\n    else:\n        interpTemp = interpolate_to_2d(pos=pos, unit=self.ulength,\n                                       values=temp, bins=bins,\n                                       xrange=xrange, yrange=yrange,\n                                       zrange=zrange, cut=cut,\n                                       weights=dens)\n\n    # Plot:\n    fig, ax = plt.subplots(figsize=(8, 6.4))\n    fig.subplots_adjust(left=0.18, right=0.82, bottom=0.14, top=0.94,\n                        wspace=0, hspace=0)\n\n    im = ax.imshow(np.log10(interpTemp), vmin=self.vmin, vmax=self.vmax,\n                   extent=(xrange[0], xrange[1], yrange[0], yrange[1]),\n                   origin='lower', cmap='afmhot')\n    ax.text(0.95, 0.05, f'{time:.2f} Myr', color='k',\n            ha='right', va='bottom', transform=ax.transAxes,\n            bbox={'facecolor': 'white', 'edgecolor': 'none',\n                  'boxstyle': 'round', 'alpha': 0.5})\n    ax.set_aspect('equal')\n    ax.set_xlabel(f'$x$ [{self.ulengthselect}]')\n    ax.set_ylabel(f'$y$ [{self.ulengthselect}]')\n    ax.set_xlim(self.xlim)\n    ax.set_ylim(self.ylim)\n\n    div = make_axes_locatable(ax)\n    cax = div.append_axes('right', size='5%', pad=0)\n    fig.colorbar(im, cax=cax, label=r'$\\log_{10}(T \\ [\\mathrm{K}])$')\n\n    # Save:\n    print('  * Figure generated successfully')\n    funcname = 'temp'\n    self.save(fig=fig, funcname=funcname)\n\n    # Display figure:\n    if self.show is not True:\n        print('  * Interactive display of figure is NOT allowed')\n        plt.close()\n    else:\n        print('  * Interactive display of figure is now running')\n        plt.show()\n\n    return None\n</code></pre>"},{"location":"install/","title":"Installation","text":""},{"location":"plot/","title":"How to make plots","text":""},{"location":"plot/#using-the-terminalplot-class","title":"Using the TerminalPlot class","text":""},{"location":"plot/#on-the-command-line","title":"On the command line","text":""},{"location":"plot/#inside-a-jupyter-notebook","title":"Inside a Jupyter Notebook","text":""}]}